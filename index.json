[{"uri":"/posts/aix-system-upgrade","tags":["AIX"],"content":"AIX  系统升级 还是 比较 方便 ， 本文 将 简单 介绍 如何 通过  AIX  的 图形界面 工具  smitty  来 安装 。 系统 环境 ： 当前 系统 版本 为 ： 7100-03-05-1524 目标 版本 为 ：7100-04-02-1614 获取 安装 补丁 从  IBM Fix Center  下载 补丁 在 安装 系统 补丁 时 ， 首先 需要 获取 系统升级 补丁 ， 对于 非  IBM  内部 服务器 来说 ， 通常 我们 可以 到  IBM Fix Center  网站 中 获取 到 对应 的 补丁 文件 。1.  首先 选择 适当 的 操作系统 2.  选择 对应 的 版本信息 ， 点击  continue  进入 到 补丁 列表 页 3.  下载 所 需 的 补丁 直接 将 含有 补丁 的 系统 挂 在 到 本地 对于  IBM  内部 系统 来说 ， 我们 可以 直接 挂载  rtpmsa  服务器 到 本地 ， 来 获取 补丁 文件 ：mount rtpmsa.raleigh.ibm.com:/msa/.projects/p10/ibmpublic /mnt 安装 前 的 准备 在 开始 安装 补丁 之前 ， 还要 确保 当前 系统 中 没有 任何  installp  文件 锁 存在 ， 可以 通过 下面 命令 查看 当前 系统 中 存在 哪些  installp  锁 ：/usr/sbin/emgr -P 上 图 说明 当前 我们 的 系统 中 存在  6  个  installp  文件 锁 ， 在 安装 之前 我们 需要 确保 这些 所 全部 被 释放 掉 ： 释放 锁  IV69033s9a/usr/sbin/emgr -r -L IV69033s9a 释放 后 确认 是否 还有 锁 存在 /usr/sbin/emgr -P 重复 上述 指令 ， 直到 所有 的 锁 全部 为 释放 掉 。 安装 补丁 当 所有 锁 全部 被 释放 掉 后 ， 就 可以 升级  AIX  系统 了 ， 首先 进入 到 补丁 目录 ， 这里 我们 是 通过 挂载 的 方式 获取 补丁 的 ， 因此 进入 到 挂 在 目录 ：cd /mnt/inst.images/aix/7.1/7100-04-03.2-1642_full 启动  smittysmittysmitty  启动 以后 ， 依次 按照 下图 安装 补丁 ： 因为 我们 已经 进入 到 补丁 目录 ， 因此 这里 的 路径 选择 当前 路径  ./  即可 选择 接受  license： 将 光标 移动 到  ACCEPT new license agreements?， 按 下  Tab  键 切换 成  Yes  即可 按 下  Enter  键 ， 弹 出 确认 框 ， 再次 按  Enter  键 ， 开始 安装 。 过程 可能 需要 会 持续 十几 到 几十分钟 ， 慢慢 等待 。 出现 下图 ， 表明 安装 成功 。 最后 重启 系统 reboot","title":"AIX System Upgrade","oriTitle":"AIX System Upgrade"},{"uri":"/posts/spectre-meltdown-for-aix","tags":["AIX","CentOS","Ubuntu"],"content":"Spectre/Meltdown  漏洞 2018  新年伊始 ，Google  安全 研究 团队 就 爆出 了 英特尔 处理器 芯片 的 两个 重要 漏洞  Spectre  和  Meltdown。 黑客 可以 通过 这些 漏洞 获取 系统 中 的 一些 机密信息 ， 比如 登录 密码 、 登录 秘 钥 、 用户 私人 照片 、 邮件 甚至 是 商业 秘密文件 等 。 在 漏洞 被 爆出 的 同时 ， 多个 系统 厂家 第一 时间 提供 了 补丁 文件 来 修复 这 一 硬件 漏洞 。 本文 将 介绍 如何 在  AIX/CentOS7  系统 中 安装 这些 补丁 文件 来 修复 这 两个 漏洞 。AIX 安装 前 的 准备 虽然  IBM  第一 时间 放出 了 针对 于  AIX  的   补丁 ， 但是 这些 补丁 并 不是 通用 的 。 不同 的 统 版本 必须 使用 与 之 对应 的 补丁 ， 下面 表格 中 列出 了  AIX 7.1  各个 版本 对应 的 补丁 版本信息 。 版本  |  补丁 号  |---  | ---7.1.4.3 | IJ03032m3a.180125.epkg.Z7.1.4.3 | IJ03032m3b.180125.epkg.Z7.1.4.4 | IJ03032m4a.180125.epkg.Z7.1.4.5 | IJ03032m5a.180116.epkg.Z7.1.5.0 | IJ03033m1a.180116.epkg.Z7.1.5.1 | IJ03033m1a.180116.epkg.Z 在 安装 补丁 之前 ， 首先 查看 当前  AIX  系统 版本信息 是否 存在 于 上面 列表 中 ， 可以 通过 下面 命令 获取 当前 系统 版本信息 ：oslevel -s 我 当前 的 系统 版本 为  7100-04-03-1642， 对应 的 补丁 号 为  IJ03032m3b.180125.epkg.Z 如果 你 当前 的 系统 版本 没有 出现 在 上述 表格 中 ， 则 需要 将 系统升级 到 指定 的 版本 ， 关于 如何 升级  AIX  系统 ， 请 参考  AIX  系统升级  。 安装 补丁 补丁 的 安装 也 比较简单 ， 下面 列出 了 安装 补丁 所 需要 的 命令 ： 下载 并 解压 补丁 到  /tmp/spectremeltdownfix  目录 emgr  的  -p  选项 用于 检测 补丁 是否 可以 被 正确 安装 到 系统 中 ， 而 并 不会 真正 去 安装 补丁 wget ftp://aix.software.ibm.com/aix/efixes/security/spectremeltdownfix.tar -O /tmp/spectremeltdownfix.tar \\  && tar xvf /tmp/spectremeltdownfix.tar -C /tmp \\  && cd /tmp/spectremeltdownfix \\  && emgr -e IJ03032m3b.180125.epkg.Z -p 安装 补丁 当前 版本  7100-04-03-1642  对应 的 补丁 号 为  IJ03032m3bemgr -e IJ03032m3b.180125.epkg.Z -X 删除 补丁 文件 rm -rf /tmp/spectremeltdownfix /tmp/spectremeltdownfix.tar 当 补丁 安装 完成 后 ， 需要 对系统 进行 重启 ：reboot 至此 ， 补丁 安装 完毕 。CentOS 7CentOS  下 安装 这 两个 补丁 比较简单 ， 首先 下载 检测 脚本 检测 系统 是否 受 这 两个 漏洞 的 影响 ： 下载 检测 脚本 wget https://access.redhat.com/sites/default/files/spectre-meltdown--a79614b.sh -O /tmp/spectre-meltdown.sh 执行 检测 脚本 bash /tmp/spectre-meltdown.sh 如果 发现 系统 中 存在 着 两个 漏洞 ， 只 需 更新 系统  kernel  即可 ：yum update -y kernel microcode_ctl 之后 自行  reboot  命令 重启 系统 即可 。Ubuntu 同样 ， 首先 获取 检测 脚本 检测 系统 当前 是否 收到 这 两个 漏洞 的 影响 ：wget https://raw.githubusercontent.com/speed47/spectre-meltdown-checker/master/spectre-meltdown-checker.sh 对 有 响应 的 系统 执行 下面 更新 操作 ：sudo apt-get install linux-generic linux-headers-generic linux-image-generic 之后 自行  reboot  命令 重启 系统 即可 。","title":" 为 系统 安装  Spectre/Meltdown  补丁 ","oriTitle":"为系统安装 Spectre/Meltdown 补丁"},{"uri":"/posts/compile-php-apache","tags":["PHP","Apache","CentOS"],"content":"Apache  是 迄今为止 全世界 中 使用 最 广泛 的  WEB  服务器软件 ， 它 快速 、 可靠 并且 可 通过 简单 的 API 扩充 ， 将  PHP，Python  等 解释器 编译 到 服务器 中 。PHP  是 最 流行 的  WEB  开发 语言 之一 ， 它 简单 ， 易 上 手 ， 尤其 是  PHP7  的 发布 ， 对  PHP  的 性能 有 了 质 的 飞跃 。 并且  PHP  是 世界 上 最好 的 语言 （ 来 打 我 呀 🤣） 虽然 各种 发行版 的  Linux  系统 为 我们 提供 了 很 方便 的 包 管理工具 来 帮助 我们 快速 安装  PHP  和  Apache， 比如  Ubunt  系统 的  apt，RedHat  系列 的  yum。 这些 工具 使用 起来 简单 便捷 ， 只 需 通过 简单 的 几行 命令 ， 即可 快速 搭建 出  PHP + Apache  的  WEB  环境 ， 最 重要 的 是 ， 这些 工具 能够 自动 为 我们 处理 最 令人恼火 的 包 依赖 问题 。 通常 情况 下 ， 使用 包 管理工具 来 安装 这些 中间件 ， 是 比较 明智 的 选择 ， 如 ： 可以 快速 安装  apache  和  phpsudo yum install httpd php -y 但 总 有些 时候 ， 需要 我们 手动 对 他们 进行 编译 安装 ， 比如 ： 当 我们 需要 在 系统 中 安装 多个 不同 版本 的  Apache  或是  PHP  的 时候 。 当 我们 想要 有 更 多 自定义 功能 选择 的 时候 。 当 我们 需要 对 源码 作出 改动 的 时候 。 当 我们 的 系统 无法 连接 网络 的 时候 。 本文 将 详细 介绍 如果 在  CentOS 7  中 通过 手动 编译 的 方式 来 安装  Apache2.4  和  PHP5.6。 安装 前 的 准备 在 开始 编译 之前 ， 首先 需要 确保 系统 中 已经 正确 安装 了  gcc  和  make。gcc  是  Linux  系统 下 的 一款 开源 的 编译器 工具 ， 他 可以 用来 编译 由  C，C++，Java，Object-C  等 一系列 语言 变 编写 的 源码 文件 ， 来 生成 可 执行 的 二进制 文件 。make  是 另 一款  Linux  下 强大 的 开源 命令行 工具 ， 它 通过 解析 定义 在  Makefile  文件 中 的 一系列 规则 ， 实现 项目 源码 的 自动化 编译 功能 。 在 某些 系统 中 ， 这 两款 工具 默认 可能 并 没有 被 安装 ， 我们 可以 通过 查看 他们 的 版本信息 来 简单 检测 系统 中 是否 已经 安装 了 这 两款 工具 ： 查看  gcc  版本信息 gcc -v 查看  make  版本信息 make -v 可以 通过 下面 的 命令 安装 这 两款 工具 ：yum  是  RedHat  旗下  Linux  发型 包 中 的 包 管理工具 sudo yum install gcc make 安装  Apache 由于  PHP  的 安装 依赖于  Apache  模块 ， 因此 需要 先 安装  Apache。 安装 前 的 准备 安装 必要 的 依赖 库 和 工具 ：yum install -y expat-devel pcre-devel wget 准备 源码 Apache  源码 可以 直接 从 官方网站   中 直接 获取 ， 也 可以 通过 下面 命令行 的 方式 获取 到 ： 创建 临时 目录 保存 源码 mkdir /tmp/source 下载  Apache  源码 wget http://mirrors.shu.edu.cn/apache/httpd/httpd-2.4.29.tar.bz2 -O /tmp/source/httpd-2.4.29.tar.bz2 解压 源码 到  /tmp/source/httpd-2.4.29  目录 下 tar xvf httpd-2.4.29.tar.bz2 -C /tmp/sourcewget  命令 会 将  Apache  源码 包 下载 到  /tmp/source  目录 下 。tar  命令 将 压缩文件 解压 到  /tmp/source/httpd-2.4.29  目录 中 APR  和  APR-Util 在 编译  Apache  时 还 需要  Apache  旗下 额外 两个 开源 库  APR  和  APR-Util， 这 两个 库 为  Apache HTTP server  提供 了 必要 的 运行 时 环境 。 我们 可以 提前 在 系统 中 手动 安装 好 这 两个 库 ， 并 在 编译  Apache  时 指定 这 两个 库 的 路径 ； 或者 是 更 简单 的 办法 ， 将 这 两个 库 的 源码 文件 放到  Apache  源码 目录 下 的  srclib  目录 中 ， 这样 在 编译  Apache  的 同时 ， 会 自动 为 我们 编译 这 两个 库 文件 ： 首先 进入 到  apache  源码 目录 下 的  srclib  目录 中 cd /tmp/source/httpd-2.4.29/srclib 下载 并 解压  APR  源码 wget http://mirrors.hust.edu.cn/apache/apr/apr-1.6.3.tar.bz2 && \\  tar xvf apr-1.6.3.tar.bz2 下载 并 解压  APR-Util  下载 源码 wget http://mirrors.shu.edu.cn/apache/apr/apr-util-1.6.1.tar.bz2 && \\  tar xvf apr-util-1.6.1.tar.bz2 重命名  apr  源码 目录 和  apr-util  源码 目录 ， 去掉 版本信息 mv apr-1.6.3 aprmv apr-util-1.6.1 apr-util>  注意 ， 最后 两步 重命名 操作 是 必要 的 ， 一定 要 去掉 文件名 后面 的 版本号 ， 否则 编译 过程中将 会 提示 无法 找到  APR  和  APR-Util  库 。 开始 安装 安装 过程 比较简单 ， 首先 进入 到  Apache  源码 目录 下 cd httpd-2.4.29 依次 执行 以下 三个 命令 ：{{}}./configure --prefix=/usr/local/apache2.4.29/ \\--enable-so \\--enable-modules=most \\--with-mpm=prefork \\--with-included-apr 编译 make 安装 sudo make install{{}} 第一行 执行  configure  命令 ， 事实上 ，configure  是 一个  SHELL  脚本 文件 ， 该 脚本 是 由  Apache  开发人员 使用  autoconf  工具 生成 的 ， 主要 用于 检测 当前 系统 是否 满足 安装  Apache  的 需求 、 设置 一些 安装 项 、 以及 生成  Makefile  文件 等 。 通过  ./configure -h  命令 可以 打印 出 完整 的 帮助 文档 信息 。 下面 对 我们 使用 到 的 选项 做 些 简单 描述 ：--prefix  指定 了  Apache  将要 被 的 安装 路径 。--enable-so  启用 动态 加载 模块 ， 这样 我们 就 可以 通过 修改  Apache  的 配置文件 直接 开启 或 停用 模块 ， 而 不用 重新 编译  Apache  源码 。enable-modules=mostwith-mpm=prefork  用于 指定  Apache  的 多 模块 处理 。--with-included-apr  通知 编译器 使用 我们 刚刚 拷贝到  srclib  目录 下 的  APR  库 。 当  configure  脚本 执行 成功 后 ， 下 一步 就是 调用  make  命令 ， 该 命令 会 根据 上 一步 生成 出来 的 的  Makefile  文件 中 定义 的 规则 ， 对 源码 进行 编译 ， 最终 生成 可 执行 的 二进制 文件 。 该 过程 可能 会 花费 一些 时间 来 完成 。 最后 ， make install  指令 表明 开始 执行  Makefile  中 的  install  规则 ， 将 生成 出 的 文件 复制到 我们 通过  --prefix  指定 的 路径 下 。 由于 我们 所 指定 的 安装 路径  /usr/local/apache2.4.29  属于 系统 路径 ， 因此 需要 使用  sudo  转变成  root  权限 安装 。 至此 ，Apache  已经 被 成功 安装 到 我们 的 系统 中 ， 可以 通过 命令  /usr/local/apache2.4.29/bin/httpd -v  检测 我们 的 安装 结果 ， 该 命令 会 返回 我们 所 安装 的  Apache  的 版本信息 。 可以 通过 命令  /usr/local/apache2.4.29/bin/apachectl start|stop|restart  来 启动 ， 停止 以及 重启  Apache web  服务 。 设置 环境变量 如 你 所 见 ， 当 我们 想要 执行 某个  Apache  命令 时 ， 每次 都 需要 指定 命令 所在 的 完整 路径 信息 。 这 是 一件 及其 麻烦 的 事 ， 最好 是 能 像 执行 系统 中 其他 命令 那样 ， 直接 在 命令行 输入 命令 ， 系统 会 自动 为 我们 找到 该 命令 所在 的 位置 。 系统 环境变量  PATH  正是 我们 所 需要 的 ， 它 的 值 是 一系列 以 分 号 分割 的 路径 ， 当 我们 在 终端 执行 任意 命令 时 ，Linux  系统 会 依次 在  PATH  环境变量 中 指定 的 路径 下 搜索 要 执行 的 命令 ， 并 执行 第一个 被 找到 的 命令 。 可以 通过 在 命令行 输入  echo $PATH  打印 出 当前 环境变量  PATH  中 的 值 。Apache  所有 可执行文件 都 被 保存 到 了 安装 路径 下 的  bin  目录  /usr/local/apache2.4.29/bin  中 ， 因此 我们 只 需 将 该 路径 信息 保存 到 环境变量  PATH  中 即可 ， 添加 环境变量 非常简单 ：sudo vim /etc/profile.d/httpd.sh 输入 小写字母  i  进入  VIM  的 编辑 模式 ， 拷贝 一下 内容 到 文件 中 ：pathmunge /usr/local/apache2.4.29/bin 按 下  ESC  键 退出  VIM  的 编辑 模式 ， 按 下 冒号 （:） 键 进入  VIM  的 命令行 模式 并 输入  wq， 表示 保存 并 退出 。pathmunge  命令 会 将  /usr/local/apache2.4.29/bin  目录 放到 系统 环境变量  PATH  指定 的 搜索 路径 的 最 前端 。 但 此时 环境变量 并 没有 生效 ， 我们 可以 打开 一个 新 的 终端 ， 或是 通过 手动 执行命令  . /etc/profile  来 使 其 生效 。 此时 再次 查看  PATH  内容 ：echo $PATH，Apache  路径 已经 出现 自 在 了 首位 。 这时 我们 就 可以 直接 执行  httpd -v  命令 ， 而 无需 在 指定 完整 路径 信息 了 。{{}} 由于 我们 修改 的 是 全局 的  PATH  环境变量 ， 这 意味着 改动 将 对 所有 用户 都 生效 ， 当然 我们 也 可以 针对 某些 用户 进行 改动 ， 其 方式 是 修改 用户 根目录 下 的  .bash_profile  文件 。{{}}Apache  配置文件 Apache  有着 丰富 的 配置 选项 ， 针对 不同 的  server， 不同 的 场景 ， 配置 信息 都 会 有所不同 ， 下面 我们 将 介绍 一些 常用 的  Apache  配置 信息 。Apache  配置文件 位于 安装 目录 下 的  conf/httpd.conf  文件 中 。User daemon  指明  apache  子 进程 所属 的 用户 ， 该 用户 必须 是 当前 系统 中 的 一个 有效 的 用户 。 通常 为 创建 一个 名为  apache  的 用户 ， 并 将 该 值 修改 为  apache。Group daemon  指明  apache  子 进程 所属 的 用户组 ， 该组 必须 是 当前 系统 中 的 一个 有效 的 组 。 通常 为 创建 一个 名为  apache  的 组 ， 并 将 该 值 修改 为  apache。 启动 / 停止  Apache 当 我们 配置 好  Apache  之后 ， 就 可以 通过  apachectl  命令 来 启动  Apache http server  了 ：apachectl  start 此时 打开 浏览器 ， 输入  http://127.0.0.1  显示  It works!， 表示  Apache Web  服务器 已经 安装 成功 。 除了  start  参数 之外 ，apachectl  命令 还 可以 接受 一下 参数 ：apachectl start|stop|restart #  启动 | 停止 | 重启 apachectl –v #  查看  Apache  版本信息 apachectl –f configurationfilename #  手动 指定 apache 配置文件 apachectl –t #  检查 Apache 配置文件 语法 是否 有 错误 apachectl -t -D DUMP_MODULES #  列出 当前 Apache 所有 模块 apachectl -t -D DUMP_VHOSTS #  列出 当前 所有 虚拟主机 模块 编译  PHPApache  安装 好 之后 ， 就 可以 开始 安装  PHP  了 ，PHP  的 安装 流程 与  Apache  类似 。 安装 前 的 准备 首先 安装 编译  PHP  时 所 需 的 必要 库 ：yum install –y perl \\  libxml2-devel \\  bzip2-devel \\  curl-devel \\  openjpeg-devel \\  libjpeg-turbo-devel \\  libpng-devel \\  libmcrypt-devel 这些 所 需 的 必要 库 ， 很大 程度 上 取决于 你 编译  PHP  时 指定 的 扩展 库 ， 例如 安装 时 如果 你 指定 了 安装  PHP  的  jpeg  扩展 库 ， 那么 系统 中 就要 预先 安装 好  libpng-devel  库 。 准备 源码 开始 安装 {{}}Warning message{{}}{{}}{{}}:  文件名 可以 是 任意 的 。 参考 APR  和  APR-UtilAPR  和  APR-Util  是  Apache  基金会 下 的 两款 开源 库 ，Apache  的  HTTP Server  就 依赖于 这 两款 库 ， 它们 为  Apache HTTP server  提供 了 运行 时 的 依赖 。Apache HTTP server  在 运行 时 依赖于  APR  和  APR-Utils  这 两个 库 ， 因此 在 编译 安装  Apache  之前 ， 首先 确保 系统 中 已经 安装 了 这 两个 库 。 最 简单 的 方式 是 直接 通过 包 管理工具 进行 安装 ：yum install -y apr apr-util 也 可以 选择 手动 编译 的 方式 来 安装 :APR： 首先 在 系统 中 安装  APR。{{}} 下载 源码 wget http://mirrors.hust.edu.cn/apache//apr/apr-1.6.3.tar.bz2 解压  APR  源码 tar xvf apr-1.6.3.tar.bz2 进入 到 源码 目录 cd apr-1.6.3./configure --prefix=/usr/local/aprmakesudo make install{{}} 第  6  行 ,  执行  configure  脚本 ， 该 脚本 主要 用于 检测 系统 是否 满足 安装 该软件 的 需求 ， 设置 ， 以及 生成  Makefile  文件 等 。prefix  选项 指定 了 我们 想要 安装 的 目录 。 通过  ./configure -h  可以 打印 出 完整 的 帮助 文档 。 第  7  行 ， 执行  make  命令 ， 根据 生成 的  Makefile  文件 ， 执行 一系列 特定 的 操作 ， 最终 生成 软件 所 需 的 所有 二进制 文件 ， 配置 信息 ， 帮助 文档 等 。 第  8  行 ， 将 所有 必要 的 文件 复制到 第  6  行 中 通过  prefix  选项 指定 的 安装 目录 中 ， 由于 我们 指定 的 安装 目录 的 父 目录  /usr/local  为 系统目录 ， 只有  root  用户 才 有 权限 对 该 目录 进行 写 操作 ， 因此 ， 如果 是非  root  用户 执行  make install  命令 ， 需要 使用  sudo  切换 到  root  用户 。APR-Util：APR-Util  的 安装 方式 与  APR  的 安装 方式 完全相同 ， 除了 几个 特定 的 安装 参数 外 ：{{}} 下载 源码 wget http://mirrors.shu.edu.cn/apache//apr/apr-util-1.6.1.tar.bz2 解压  APR-Util  源码 tar xvf apr-util-1.6.1.tar.bz2 进入 到 源码 目录 cd apr-util-1.6.1./configure \\  --prefix=/usr/local/apr-util \\  --with-apr=/usr/local/aprmakesudo make install{{}} 由于  APR-Util  依赖于  APR， 因此 在 第  8  行 中 我们 通过  --with-apr  参数 指定 了  APR  的 安装 目录 ， 来 通知  APR-Util  去 哪里 可以 找到  APR  依赖 。{{}} 如果 在 安装  APR  时 将 所有 库 文件 和 头文件 安装 到 了 系统 的 默认 目录 中 （ 并 及时 更新 了  ldconfig）， 那么 在 安装  APR-Util  时 就 可以 不用 指定  --with-apr  参数 。{{}} 开始 安装 一切 准备就绪 ， 是 时候 开始 安装  Apache  了 。  首先 是   获取  Apache  源码 ：Apache httpd serverwget http://mirrors.shu.edu.cn/apache/httpd/httpd-2.4.29.tar.bz2 解压 源码 tar xvf httpd-2.4.29.tar.bz2","title":"CentOS7  下 编译 安装  Apache2.4 + PHP5.6","oriTitle":"CentOS7 下编译安装 Apache2.4 + PHP5.6"},{"uri":"/posts/db2-install","tags":["DB2","DevOps","数据库"],"content":" 一不小心 ， 又 到 了  DB2  升级 的 时候 了 😂 。 每次 升级 过程 中 总是 会 遇到 各种各样 的 升级 问题 ， 这次 终于 下定决心 记录 下 所有 升级 步骤 ， 以便 供 下次 升级 参考 使用 。# 安装  DB2 本次 升级 是 将  DB2  从 V10.5  升级 到  V11， 属于 大 版本升级 ， 不同于 小 版本 的 升级 ， 小 版本 直接 升级 数据库 文件 （/opt/IBM/db2/V10.5） 和 实例 即可 。 而 对于 大 版本升级 来说 ， 首先 要 在 系统 上 安装 新版 的 数据库 ， 新 版本 数据库 的 安装 并 不会 对系统 中 的 老版 数据库 造成 任何 影响 ， 因为 新 版本 数据库 将 会 被 安装 在 另 一个 独立 的 目录 中 ， 当 新版 数据库 安装 完成 后 ， 在 对 当前 系统 中 的 实例 以及 实例 下 的 数据库 进行 升级 。 安装 前 的 检测 在 安装  DB2  之前 ， 对系统 环境 进行 检测 是 很 有 必要 的 ， 这 可以 帮助 我们 快速 查看 当前 系统 是否 满足 安装 某个  DB2  版本 的 必要条件 。 检查 脚本  db2prereqcheck  可以 在  DB2  的 安装 目录 中 找到 ： 检查 当前 系统对 每个  DB2  版本 的 支持 情况 db2prereqcheck 检查 当前 系统对 指定  DB2  版本 的 支持 情况 db2prereqcheck -v 11.1.2.2 一旦 系统 满足 了 我们 所 要 安装 的  DB2  版本 所有 要求 ， 就 可以 进行 安装 了 。 安装 安装  DB2  总体 来说 有 两种 方式 ： 图形界面 方式 安装 （db2setup）  和   命令行 方式 安装 （db2_install）。 图形界面 安装 比较简单 ， 直接 在 安装 目录 下 运行  db2setup  命令 ， 该 命令 会 打开  DB2  的 图形 安装 界面 ， 按照 页面 提示 操作 一步 一步 进行 安装 即可 ， 这里 就 不 做 过 多 介绍 了 。{{}} 从  DB2 response  文件 进行 安装 ， 也 是 通过 调用  db2setup  命令 ， 并 通过  -r  参数 指定  response  文件 进行 安装 的 ， 如 ： db2setup -r db2server.rsp{{}} 这里 主要 介绍 一下 命令行 安装 方式 ， 执行 安装 目录 下 的  db2install  命令 ， 便 会 触发 命令行 安装 方式 ， 该 命令 可以 接收 多个 命令行 参数 ， 下面 介绍 了 几个 常用 的 参数 ， 要 想 获取 完整 的 参数 列表 帮助 文档 ， 可 执行  db2install -h  命令 查看 .-n： 指定 为 非 交互 模式 。 如果 指定 了 该 参数 ，-b  和  -p  也 必须 同时 被 指定 。-b： 指定  DB2  的 安装 路径 。-p：-l： 指定 安装 日志 文件 路径 和 名称 ，root 用户 默认 /tmp/db2_install.log. 进程 号 。-y： 表示 接受  DB2  协议 。 根据 是否 指定 了  -n  参数 ， 命令行 安装 方式 又 分为   交互 模式   和   非 交互 模式 ， 下面 分别 介绍 一下 这 两种 安装 方式 。 交互式 交互式 是 指 在 安装 过程 中 ， 系统 会 多次 出现 提示信息 ， 并 等待 用户 输入 相关 信息 。 这 也 是 一种 比较简单 的 安装 方式 。 启动 交互 安装 模式 最 简单 的 方法 是 在 安装 目录 下 直接 执行  db2_install  命令 ， 该 命令 默认 开启 的 是 交互 模式 ， 下图 展示 了 交互 模式 的 安装 过程 ： 安装 过程 中 有 以下  4  项 需要 用户 提供 输入 ：①  输入  YES  表示 接受  DB2  许可 。②  选择 要 安装 的 类型 ， 输入  SERVER  表示 安装 完整 的 服务器端 。③  选择  DB2  安装 路径 ， 输入  YES  使用 默认 路径 。④  选择 是否 安装  pureScale  功能 ， 输入  NO  表示 不 需要 。 非 交互式 如果 只是 安装 几台  DB2 server， 通过 交互式 命令 来 安装 是 完全 可行 的 ， 但是 如果 有 几十台 甚至 上百 台 服务器 需要 进行 安装操作 ， 非 交互式 模式 才 是 最好 的 选择 ， 不仅 节省 大量 的 输入 时间 ， 同时 可以 将 安装 命令 集成 到 安装 脚本 中 ， 实现 自动化 安装 。 如 ： 将  DB2  安装 到  /opt/IBM/db2/V11.1  目录 下 ./db2_install -n -y -b /opt/IBM/db2/V11.1 -p XXXXX{{}} 由于 本次 只是 升级 安装 ， 系统 中 已经 存在 了 必要 的  DB2  用户 和 组 ， 如果 是 初次 安装  DB2， 并且 选择 命令行 模式 安装 ， 必须 自行 创建 好 用户 和 组 。{{}} 升级 实例 当 新版 数据库 安装 完成 后 ， 就 可以 依次 升级 数据库 实例 和 实例 下 的 数据库 了 。 首先 确保 断开 一切 与 数据库 的 连接    停止  WEB  服务器 ， 禁用 所有  crontab   关闭  Cast Iron   停止  DataOptimizer， 移除 数据库  trigger 对 主 数据库 进行 离线 备份 nohup db2 backup db saleconn to /db/a1insctp/db2backup compress & 设置  HADR 首先 检查 数据库  HADR， 确保 处于  PEER  状态 。db2pd -db saleconn -hadr 确保  HADR_SYNCMODE  的 属性 为  NEARSYNC 获取  HADR_SYNCMODE  状态 db2 get db cfg for saleconn | grep -i SYN{{}}info{{}}{{}}note{{}}","title":"DB2  大 版本升级 ","oriTitle":"DB2 大版本升级"},{"uri":"/posts/design-patterns","tags":["Python","Design Patterns"],"content":" 代码 写 的 越 多 ， 就 愈发 对 代码 的 结构 要求 更 多 ， 常常 会 因为 如何 实现 一个 类 或是 方法 而 纠结 几个 小时 。 编码 ， 不仅仅 是 为了 完成 某个 功能 ， 它 更 像是 一种 艺术 ， 结构设计 良好 的 代码 ， 不仅 可以 大大 地 提高 可读性 和 维护性 ， 还 能 令人 赏心悦目 ， 心旷神怡 。 设计模式 ， 就是 为了 解决 某些 开发 过程 中 的 实际 问题 而 提供 的 一些 编码 解决方案 ， 这些 方案 是 由 很多 开发人员 通过 在 平时 的 开发 中 总结 出来 的 一套 比较 成熟 的 解决办法 ， 设计模式 不 依赖于 编程语言 本身 ， 任何 面向对象编程 语言 都 可以 套用 这些 通用 的 设计模式 ， 虽然 不同 的 语言 之间 在 实现 的 过程 中 会 有 一些 差异 ， 但 总 的 思想 是 一样 的 。 学习 设计模式 ， 将 会 受益 终身 ！ 从 本文 开始 ， 我 将 一一 记录 下 我 所学 到 的 设计模式 ， 那么 ， 开始 吧 ！ 单 例 模式 每种 设计模式 都 尝试 解决 一种 问题 第一个 设计模式 - 单 例 模式 ： 单 例 模式 应该 是 所有 设计模式 之中 最 简单 ， 也 是 应用 最 广泛 的 一种 设计模式 了 。 单 例 模式 ， 顾名思义 ， 就是 在 整个 代码 的 生命周期 内 ， 只有 一个 类 的 实例 存在 ， 或者说 ， 对于 一个 单 例 模式 的 类 来说 ， 无论 实例 化 它 多少 次 ， 最终 都 只 会 返回 同一个 实例 对象 。 这 通常 是 很 有用 的 ， 比如 在 我们 的 项目 中 ， 用于 访问 数据库 的  DB  类 ， 在 任意 时刻 ， 我们 都 希望 只有 一个 对象 来 访问 我们 的 数据库 资源 ， 这样 ， 在 同一 时刻 ， 对 数据库 发起 多个 操作 请求 时 ， 才 不会 对 资源 的 访问 造成 冲突 ；  在 比如 ， 用于 记录 日志 信息 的  log  类 ， 如果 不能 保证 同时 只有 一个 日志 类 的 实例 ， 势必会 造成 日志 的 混乱 ， 因为 多个 不同 的 日志 实例 同时 向 同一个 日志 文件 中 写入 信息 时 ， 所有 信息 将 会 穿插在 一起 被 保存 到 日志 文件 中 ， 显然 这 并 不是 我们 所 期望 的 。 单 例 模式  UML  图 ： 下面 将 详细 介绍 在  Python  中 实现 单 例 模式 的 各种 方法 。 通过  new  来 实现 的 单 例 模式 在  Python  中 ， 最 简单 的 实现 方法 ， 就是 通过  Python  中 的  new  方法 ， 来 返回 我们 所 需 的 实例 。{{}}class Singleton(object):    def new(cls):        if not hasattr(cls, 'instance'):            cls.instance = super(Singleton, cls).new(cls)        return cls.instances1 = Singleton()print(\"Object created\", s1)s2 = Singleton()print(\"Object created\", s2){{}} 输出 结果 ：Object createdObject created 可以 看到 ， 虽然 代码 中 实例 化 了 两次  Singleton  类  s1  和  s2，  但 他们 返回 的确 是 同一个 对象 。 代码 解析 : 第  2  行 ： 实现  new  方法 ， 注意 ， Python  会 自动 将  Singleton  类 本身 作为 第一个 参数传递 个 该 方法 。 第  4  行 ： 创建 一个 类 属性  instance， 并 将 新创建 的 对象 赋 给 该 属性 。 通过 类 方法 实现 单 例 模式 另 一种 常用 的 方法 是 ， 创建 一个 类 方法 和 一个 类 属性 ， 在 类 方法 中 通过 对 类 属性 的 判断 来 创建 一个 新 的 类 实例 或 直接 返回 已有 的 类 实例 。{{}}class Singleton(object):    __instance = None    def init(self):        if not Singleton._instance:            print(\"initializing...\")        else:            print(\"Instance already created:\", self.getInstance())    @classmethod    def getInstance(cls):        if not cls._instance:            cls.__instance = Singleton()        return cls.__instances1 = Singleton()s2 = Singleton.getInstance()print(\"Object created\", s2)s2 = Singleton(){{}} 输出 ：initializing...initializing...Object createdInstance already created: 通过 这种 方式 方法 实现 的 单 例 模式 ， 只有 在 我们 真正 需要 创建 单 例 实例 时 ， 通过 明确 调用 类 方法  getInstance()  才 会 返回 这个 单 例 实例 ， 而 并 不 像 第一个 例子 中 那样 ， 实例 化 类 后 就 会 自动 返回 实例 ， 因此 通过 这种 方式 实现 的 单 例 模式 ， 也 尝尝 被称作   懒汉 模式 。Python  中 懒汉 模式 的 问题 由于  Python  中 并 没有 实现 面向对象 中 的 封装 ， 类似  Java  中 的  public，protect  以及  private  等 关键字 在  Python  中 也 没有 得到 实现 ， 因此 懒汉 模式 并 不能 像 在  Java  中 那样 发挥 到 极致 ， 因为 我们 无法 将  Singleton  类 的 构造方法 定义 为 私有 属性 ， 这 使得 我们 仍然 可以 使 通过  s = Singleton()  的 方式 来 实例 化 出 许多 不同 的 类 实例 来 ， 而 这些 实例 又 不 属于 同一个 实例 ：s1 = Singleton()print(id(s1))s2 = Singleton()print(id(s2))s3 = Singleton()print(id(s3)) 输出 结果 ：initializing...4385455352initializing...4385455240initializing...4385455072 从 输出 结果 看来 ， 每个 实例 化 出来 的 实例 仍然 是 不同 的 实例 ,  因此 ， 在  Python  中 ， 使用 懒汉 模式 实现 的 单 例 模式 时 ， 开发人员 必须 确保 实例 时 通过 调用 正确 的 类 方法 来 获得 的 。metaclass","title":"Python 设计模式 之  -  单 例 模式 ","oriTitle":"Python设计模式之 - 单例模式"},{"uri":"/posts/jenkins-pipeline","tags":["Jenkins"],"content":" 前言 在  DevOps  概念 大行其道 的 今天 ， 持续 部署 （CD） 作为 其 核心 概念 之一 ， 逐渐 被 各个 企业 接纳 并 采用 。 简单 来说 ， 持续 部署 就是指 开发人员 从 提交 代码 到 代码 仓库 开始 ， 经过 一系列 自动化 构建 与 测试 之后 ， 最终 将 代码 部署 到 生产 环境 中 的 一整套 自动化 流程 。 其 核心 价值 体现 在   持续   上 ， 整个 流程 要 做到 完全 自动化 ， 无需 任何 人工干预 。 下图 展示 了 最 基本 的  CD  流程 ： 目前 ， 已经 存在 很多 专门 用来 构建 这种 自动化 流程 的 工具 ， 其中 最为 著名 的 工具 非  Jenkins  莫 属 了 ， 它 是 一款 完全 开源 免费 的 工具 。Jenkins  意在 帮助 我们 快速 搭建 出 针对 任何 代码 的 构建 ， 测试 ， 部署 等 流程 。 什么 是  Jenkins PipelineJenkins  在  2.0  版本 中 引入 了  Pipeline  的 概念 ，Pipeline  就是 通过 引用 一系列  Jenkins  及其 插件 预定 义 好 的  DSL（Domain-specific language）  语法 构建 出来 的 流程 。  同时 ，Pipeline  还 支持 完整 的  Groovy  语法 ， 通过 在  Pipeline  中 编写  Groovy  脚本 ， 可以 写出 更加 灵活 的  Pipeline  来 。Pipeline  最大 亮点 ， 就是 它 允许 我们 将 整体 的 流程 根据 不同 的 功能 来 拆 分成 一个个 独立 的 阶段 （stage）， 如 上面 提及 到 的   代码 构建 ->  测试  ->  部署   等 阶段 ， 按 顺序 依次 执行 这些 拆分 出来 的 阶段 ， 并 最终 将 结果 通过 可视化 页 面向用户 展现 出来 。 下图 展示 了  Pipeline job  执行 完成 后 的 可视化 视图 ： 通过 可视化 视图 ， 我们 可以 对 当前 的 构建 流程 一目了然 。 同时 ， 它 也 能够 快速 定位 到 出现 问题 的 步骤 。 创建  Pipeline Job 接下来 ， 让 我们 创建 一个  Pipeline Job。 创建 过程 非常简单 ， 在  Jenkins  主页 ， 选择  New Item  打开 创建  Job  页面 ， 其  Job  类型 选择  Pipeline， 并 给 该  Job  指定 一个 名字 ， 之后 点击  OK  按钮 即可 ： 当  Pipeline Job  被 创建 好 后 ， 页面 会 自动 跳转 到 我们 刚刚 创建 的  Job  的 配置 页面 ， 在 该 页面 的 最 底部 ， 找到  Pipeline  部分 ， 默认 会 出现 一个 输入框 ， 该 输入框 就是 用来 保存  Pipeline  脚本 的 。 在 本文 的 介绍 中 ， 所有  Pipeline  都 是 以 这种 方式 保存 并 运行 的 。 进入  Pipeline 在 正式 开始 介绍  Pipeline  语法 之前 ， 首先 需要 清楚 一点 的 是 ， 对于 目前 最新 版本 的  Jenkins  来说 ， 存在 两种 语法 格式 的  Pipeline： 脚本 式  Pipeline（Scripted Pipeline） 和 声明 式  Pipeline(Declarative Pipeline)。 脚本 式  Pipeline 脚本 式  Pipeline  是 早期 编写  Pipelien  的 语法 ， 开发人员 通过 编写 自己 的  Groovy  脚本 来 定义  Pipeline， 虽然 这 为 我们 提供 了 很 强 的 灵活性 ， 但 需要 开发者 有 较 好 的  Groovy  编程 经验 。 示例 ： 下面 的 实例 展示 了   脚本 式  Pipeline  的 基本 语法 ：{{}}node {    stage(\"CodeStyle Check\") {        echo \"Checking...\"    }    stage(\"Build\") {        echo \"Building...\"    }    stage(\"Test\") {        echo \"Testing...\"    }    stage(\"Deploy\") {        echo \"Deploying...\"    }}{{}} 声明 式  Pipeline 而 声明 式  Pipeline  是 在  Pipeline 2.5  版本 中 新 引入 的 语法 格式 ， 相对 于   脚本 式  Pipeline  来说 ， 声明 式  Pipelien  提供 了 更加 简洁 和 灵活 的 语法 ， 新增 了 更 丰富 的 功能 ， 在 大大降低 了  Pipeline  编写 难度 的 同时 ， 又 不失 其 灵活性 。 无论 你 之前 是否 了解 过  Pipeline， 声明 式  Pipeline  都 是 你 以后 在 编写  Pipeline  道路 上 的 的 首选 方案 。 本文 将 着重 向 读者 介绍 如何 编写   声明 式  Pipeline。 示例 ： 下面 的 实例 展示 了   脚本 式  Pipeline  的 基本 语法 ：{{}}pipeline {    agent any    stages {        stage(\"CodeStyle Check\") {            steps {                echo \"Checking...\"            }        }        stage(\"Build\") {            steps {                echo \"Building\"            }        }        stage(\"Test\") {            steps {                echo \"Testing\"            }        }        stage(\"Deploy\") {            steps {                echo \"Deploying\"            }        }    }}{{}}pipeline  用于 定义  Pipeline  块 ， 所有 有关  Pipeline  定义 的 部分 必须 全部 被 定义 在 该 语句 块 内 ， 除了  Groovy  定义 的 类 ， 方法 ， 变量 等 。agent  指定 要 执行  Pipeline  的  Jenkins  节点 。stages  用来 包括 所有 的  stage。stage  用来 包括 具体 所 要 执行 的 操作 。steps  用来 包括 要 执行 的 指令 。echo  打印 字符串 。Pipelin  语法 本 节 将 向 读者 详细 介绍   声明 式  Pipeline  中 的 语法 。agent 当 我们 要 执行 某个  Pipeline  时 ， 必须 指定 执行 该  Pipelien  的  Jenkins  节点 ， 只有 指定 了 运行 节点 的  Pipeline  才 可以 被 执行 。 指定 执行 节点 是 通过  agent  来 定义 的 。agent  必须 被 定义 在  pipeline{}  块 的 最 顶端 ， 我们 可以 称之为 全局  agent， 用来 为 整个  Pipeline  指定 一个 要 执行 的 节点 。 可 选 的 ， 也 可以 在 某个  stage  块 中 定义  agent， 表明 为 当前  stage  指定 一个 执行 节点 ， 我们 会 在 讲解  stage  时 在 具体 介绍 。 参数 列表 agent  可以 接受 多种不同 类型 的 参数 ， 这些 参数 能够 帮助 我们 灵活 的 特定 的 一个 或是 一组 节点 ， 可用 参数 有 ：anyany  参数 表明  Pipeline  可以 在 任意 一个  Jenkins  节点 中 运行 ， 包括  master  节点 。 当 使用 该 参数 时 ，Jenkins  会 在 当前 空闲 的 节点 中 随意 选择 一个 节点 来 运行  Pipeline。 如 ：agent any。label 通过  Jenkins  节点 的  Label  属性 选择 节点 ， 如 ：agent {    label 'Linux'} 该 示例 表明 将 在 所有  Label  为  Linux  的 节点 中 随机 选择 一个 空闲 的 节点 来 执行  Pipeline。>  注意 ： 如果 指定 了 一个 不 存在 的  Label，Jenkins  会 像 处理 离线 节点 那样 ，Job 将 一直 等待 节点 上线 ， 而 并 不会 报出 任何 异常 。noednode  是 在  label  参数 的 基础 上 ， 添加 了 一些 附加 的 选项 。 它 是 一个 语句 块 ， 语句 块 中 可以 定义 以下 参数 ：label： 必选 参数 ， 与  agent  的  label  参数 功能 一样 ， 通过  Jenkins  节点 的  Label  属性 来 选择 适当 的 节点 customWorkspace： 可 选 参数 ， 指定 当前 节点 上 执行  Pipeline  或是  Stage（ 在  stage  中 设置 了  agent） 时 的 目录 。 默认 情况 下 ， 当 运行  Pipeline  时 ，Jenkins  会 在 工作 节点 机器 上 的 默认 工作 目录 （ 通过 节点 配置 页面 的  Remote root directory  选项 指定 ） 下 创建 一个 与 所 运行  Job  同名 的 子目录 作为  Pipeline  的 执行 目录 。customWorkspace  选项 可以 让 我们 手动 选择 一个 自定义 。 其 值 可以 是 一个 绝对路径 ， 也 可以 是 一个 以 该 节点 默认 的 工作 目录 为 根 路径 的 相对路径 。 示例 ：agent {    node {        label 'Linux'        customWorkspace '/tmp/Jenkins'    }} 在 这个 示例 中 ， 除了 我们 额外 使用 绝对路径 指定 了  Pipeline  的 工作 目录 为  /tmp/Jenkins  之外 ， 其 功能 与 使用  label  的 示例 功能 完全相同 。none 只有  Pipeline  最 顶端 的  agent  可以 指定 为  none  参数 ， 该 参数 表明 不 为 当前 整体  Pipeline  分配 任何 节点 ， 相应 地 ， 必须 在 每个  stage  块 中 单独 配置 一个  Jenkins  节点 ， 这样 不同 的  stage  可以 运行 在 不同 的  Jenkins  节点 中 。 如 ：{{}}pipeline {    agent none    stages {        stage(\"stage1\") {            agent any            ...        }        stage(\"stage2\") {            agent {                label \"Linux\"            }        }    }}{{}} 第  2  行 ， 没有 为 当前  Pipeline  分配 任何 执行 节点 。 第  5  行 ， 指定  stage1  可以 运行 在 任何 一个 节点 中 。 第  10  行 ， 指定  stage2  只能 运行 在  Label  是  Linux  的 节点 上 。stagesstages  是 一个 用来 包含 一个 或 多个  stage  指令 的 序列 块 ， 它 无需 任何 参数 。 每个  Pipeline  必须 有 且 只能 有 一个  stages  块 ， 而且 每个  stages  中 至少 需要 包含 一个  stage  指令 。 而  stage  是 用来 包裹 那些 真正 执行 某些 操作 的 指令 的 。 每个  stage  应当 包含 用于 去 完成 某个   比如 构建 代码 ， 执行 测试用例 ， 部署 到 生产 环境 中 去 等 ， 而 这些 步骤 一般 都 被 封装 在 各自 的  stage  中 。 一个  stages  块 中 必须 至少 包含 一个  stage  指令 。 在 整个  Pipeline  中 ， 应当 有 且 仅 有 一个  stages  块 。stages  在 使用 时 不 接受 任何 参数 。stage 在 编写 一个  Pipeline  时 ， 我们 应当 按照 不同 的 阶段 或是 不同 的 功能 ， 将  Pipeline  拆 分成 不同 的 阶段 ， 比如 在 整个  CD  流程 中 ， 一般 都 至少 包括   打包 代码 、 运行 自动化 测试 脚本 以及 部署 等 流程 。stage  就是 用来 封装 这些 流程 的 ， 我们 应当 将 这些 流程 分别 定义 在 各自 的  stage  中 ， 当 运行  Pipeline  时 ，Jenkins  会 按照 定义 时 的 顺序 依次 执行 这些 流程 。 同时 ， 最终 生成 的 可视化 页面 也 是 按照  stage  为 单位 显示 的 。stage  必须 被 包含 在  stages  中 ， 并且 至少 包含 一个 。 而 在 每个  stage  中 ， 必须 包含 其 只能 包含 一个  steps  来 执行 具体 的 指令 ， 或是 一个  parallel  指令 来 定义 需要 并行执行 的  stage， 以及 一些 可 选 的 如  agent、environment、options、tool  等 其他 指令 。 参数 列表 stage  接收 一个 字符串 参数 ， 用来 给 当前  stage  命名 。 示例 ：{{}}stages{    stage(\"build\") {        agent {            label 'Linux'        }        steps {            sh 'mvn clean install'        }    }    stage(\"test\") {        steps {            sh \"mvn test\"        }    }}{{}} 第  2  行 定义 一个 名为  build  的  stage。 第  3  行 在 该  stage  内部 定义  agent， 指明 运行 当前  stage  时 所在 的  Jenkins  节点 。 第  6  行 定义 一个  step， 这 是 该  stage  真正 执行 操作 的 地方 。 在 这个 示例 中 ， 通过  sh step  在 节点 中 执行  mvn clean install  命令 。 第  10  行 定义 一个 名为  test  的  stage， 该  stage  会 运行 在  Pipeline  中 指定 的 节点 中 。stepssteps  被 定义 在  stage  中 ， 每个  stage  必须 包含 且 只能 包含 一个  steps，  用于 调用  Jenkins  中 的 特定 指令 ， 比如 在 前面 的 例子 所 中 使用 的  sh  指令 。XXXXsteps  中 除了 可以 调用  Jenkins  中 定义 的 指令 外 ， 还 支持  script  指令 ， 在  script  中 ， 我们 可以 定义 并 执行 脚本 式  Pipeline。 示例 {{}}pipeline {    agent any    stages {        stage('Example') {            steps {                echo 'Hello World'                script {                    def browsers = ['chrome', 'firefox']                    for (int i = 0; i }} 第  6  行 ， 调用  echo  指令 来 输出  \"Hello World\"  字符串 第  8-13  行 ， 通过  script  指令 执行  Groovy  脚本 。environmentenvironment  指令 可以 帮助 我们 定义 环境变量 ， 当 在 指定 的  Jenkins  节点 中 在 执行  stage  中 的 指令 时 ， 定义 的 环境变量 会 被 添加 到 节点 机器 的 系统 环境变量 中 去 。 该 指令 既 可以 被 定义 在  pipeline  最 外层 中 来 定义 环境变量 ， 这样 定义 的 环境变量 对 所有  stage  都 有效 ， 也 可 有 定义 在 某个 特定 的  stage  中 ， 这样 定义 的 环境变量 仅仅 会 应用 到 当前  stage  执行 时 所在 的 节点 。credentials  方法 credentials  是  environment  指令 提供 了 一个 附加 的  helper  方法 ， 通过 将 我们 在  Jenkins  中 定义 的  credentials  时 指定 的  ID  作为 参数传递 给 该 方法 ， 可以 获取 到 该  credential  的 值 ， 并 将 该 值 赋值 给 指定 的 环境变量 。 使用  credentials  方法 获取 到 的  credential  的 值 仍然 是 加密 过 的 ， 因此 用户 不必 担心 敏感 信息 的 泄漏 问题 。 如果 我们 不想 将 这些  credentials  以 环境变量 的 形式 获取 ， 还 可以 使用  Jenkins  还 提供 的  withCredentials  方法 。 示例 {{}}pipeline {    agent any    environment {        CC = 'clang'    }    stages {        stage('Example') {            environment {                ANACCESSKEY = credentials('my-prefined-secret-text')            }            steps {                sh 'printenv'                echo \"${env.ANACCESSKEY}\"            }        }    }}{{}} 第  3-5  行 ， 我们 在  Pipeline  最 外层 定义 了 一个 环境变量  CC， 这个 环境变量 可以 被 该  Pipeline  中 的 所有  stage  所 引用 。 第  8-10  行 ， 我们 在  stage  中 定义 的 环境变量  ANACCESSKEY， 并 将 系统 中 预定 义 好 的  ID  为  my-prefined-secret-text  的  credential  的 值 。 该 环境变量 仅 对 当前  stage  有效 。 第  12  行 通过 执行 系统 的  printenv  命令 里 获取 所有 系统 中 所有 环境变量 ， 可以 在 输出 中 同时 看到 我们 上面 定义 的  CC  和  ANACCESSKEY  两个 环境变量 ， 并且  ANACCESSKEY  的 值 是 以  **  的 形式 展现 出来 的 。 第  13  行 ， 通过  Jenkins  中 的  env  系统 变量 来 获取 指定 的 环境变量 。optionsoptions  指令 可以 让 我们 为 当前 的  Pipeline  或 某个 特定 的  stage  设置 一些 附加 选项 。 如果 该 指令 出现 在  pipeline  块 的 最 外层 ， 则 这些 选项 对 整个  Pipeline  生效 ； 如果 该 指令 出现 在 某个  stage  内 ， 则 这些 选项 设置 仅 对 当前 的  stage  生效 。options  指令 中 可用 的 选项 ， 一部分 来自 于  Jenkins  自身 定义 好 的 ， 一部分 来自 于 某些 插件 。 并且 对 整体  Pipeline  范围 来说 可用 的 选项 和  stage  范围 可用 的 选项 也 不尽相同 ， 下面 让 我们 分别 介绍 一下 在  Pipeline  级别 中 和  stage  级别 中 一些 比较 常用 的 选项 。Pipeline  中 的 可用 选项 buildDiscarder 每当  Jenkins Job  被 执行 一次 ， 都 会 产生 一些 日志 文件 ， 或是 一些 由  Job  生成 的 归档文件 ， 当  Job  被 执行 的 次数 越 多 ， 生成 的 日志 和 归档文件 就 越 多 ， 数以千计 的 日志 文件 和 归档文件 不但 会 占用 大量 的 系统 磁盘 资源 ， 还 会 影响 到  Jenkins  性能 。 因此 定期 清理 这些 无用 的 日志 和 归档文件 非常 重要 。buildDiscarder  选项 可以 让 我们 选择 保留 该  Pipeline  最近 执行 的 多少 个  Job  的 日志 信息 ， 超过 这个 数量 的  Job  日志 信息 和 归档文件 将 被 自动 清除 ， 如 ：options { buildDiscarder(logRotator(numToKeepStr: '5')) }， 表示 只 保留 最近 执行 的  5  个  Job  的 日志 和 归档 信息 。 我们 还 可以 直接 在  Jenkins Job  的 配置 页面 中 ， 通过 配置  Discard old builds  来 达到 同样 的 目的 。disableConcurrentBuilds 默认 情况 下 ，Pipeline  支持 并行 运行 ， 即 同一个  Pipeline  可以 同时 被 执行 多次 （ 前提 是 执行  Pipeline  的  agent  设置 正确 ）。 当 有些 时候 ， 我们 并 不 希望  Pipeline  被 并行执行 ，disableConcurrentBuilds  方法 可以 帮助 我们 关闭  Pipeline  并行执行 的 能力 ， 如 : options { disableConcurrentBuilds() }skipStagesAfterUnstable 如果 设定 了  skipStagesAfterUnstable  选项 ， 则 当 某个  stage  执行 结果 被 设置 为  UNSTABLE  时 ， 将 跳 过 余下 的 所有  stage。 如 ：options { skipStagesAfterUnstable() }。timeouttimeout  选项 可 用于 设置  Pipeline  的 最大 执行 时间 ， 当 超过 指定 时间 后 ，Pipeline  将 被 自动 终止 。 如 ：options { timeout(time: 1, unit: 'HOURS') }  指定 该  Pipeline  最 多 可 执行  1  小时 。retry 就 像 该 参数 名字 的 含义 一样 ， 当  Pipeline  执行 失败 后 ， 我们 可以 通过  retry  参数 指定 尝试 重新 执行 该  Pipeline  的 次数 ， 当 尝试 过 指定 次数 后 仍然 失败 ， 则  Pipeline  状态 设置 为 失败 并 退出 执行 。 如 ：options { retry(3) }。timestamps 当 日志 信息 打印 到  Jenkins Job  的 控制台 输出 页面 时 ， 同时 打印 出 日志 的 时间 戳 信息 。 如 ：options { timestamps() }。stage  中 的 可用 的 选项 这些 选项 在  stage  中 的 使用 方式 与 在  Pipeline  中 的 使用 方式 一样 ， 只是 在  stage  中 定义 的 选项 仅 对 当前 的  stage  有效 。timeout 设置 当前  stage  的 最大 执行 时间 。retry 设置 当前  stage  执行 失败 后 可以 自动 尝试 重新 执行 的 次数 。timestamps 仅 为 当前  stage  中 的 日志 输出 设置 时间 戳 信息 。parameters 虽然 在 创建  Jenkins job  时 可以 在  Job  配置 页面 指定 执行  Job  时 所 需 的 参数 ，Pipeline  额外 还 提供 了  parameters  指令 ， 用于 声明 执行  Pipeline  时 所 需要 的 参数 列表 。parameters  指令 只能 被 包含 在  pipeline  块 的 最 外层 ， 并且 在 整个  Pipeline  块 中 只能 定义 一个  parameters  指令 。 在  parameters  指令 中 支持 调用 两个 方法 ：string()  和  booleanParam()，  分别 用于 定义 一个 字符串 类型 的 参数 和 一个 布尔值 类型 的 参数 ， 每个 方法 都 可以 接收 一下 参数 ： 参数 列表 name 必选 参数 ， 指定 参数 的 名字 。defaultValue 指定 参数 的 默认值 ， 该 参数 为 可 选 参数 ， 对于 字符串 类型 的 参数 来说 ， 如果 没有 指定 该 参数 ， 默认值 为  null； 对于 布尔值 类型 的 参数 来说 ， 如果 没有 指定 改制 ， 默认 是 为  false。description 可 选 参数 ， 为 该 参数 添加 描述 信息 ， 方法 其他 开发人员 参考 。 示例 {{}}pipeline {    agent any    parameters {        string(name: 'PERSON', defaultValue: 'Mr Jenkins', description: 'Who should I say hello to?')        booleanParam(name: 'DEBUG_BUILD', defaultValue: true, description: '')    }    stages {        stage('Example') {            steps {                echo \"Hello ${params.PERSON}\"                echo \"${params.DEBUG_BUILD}\"            }        }    }}{{}} 第  4-7  行 中 ， 我们 使用  parameters  指令 定义 了 两个 参数 ：   参数 名为  PERSON  的 字符串 类型 的 ， 该 参数 默认值 为  Mr Jenkins。   参数 名为  DEBUG_BUILD  的 布尔值 类型 参数 ， 该 参数 默认 为  true。 第  12 13  行 通过  Jenkins  内置 的  params  变量 来 获取 这 连 个 参数 的 值 。whenwhen  指令 可以 帮助 我们 编写 条件 式  stage， 即 只有 某些 条件 符合 时 ， 才 会 执行 指定 的  stage  指令 ， 它 必须 定义 在  stage  中 。Jenkins  内置 了 许多 条件 表达式 ， 让 我们 简单 介绍 一下 常见 的 表达式 。allOf 至少 包含 一个 表达式 ， 并且 当 所有 的 表达式 都 为 真是 ， 才 会 执行 该  stage。anyOf 至少 包含 一个 表达式 ， 并且 只要 有 一个 条件 为 真 ， 就 会 执行 该  stage。not 只能 包含 一个 表达式 ， 当 该 表达式 为 假 时 ， 就 会 执行 该  stage。environment 如果 存在 指定 的 环境变量 ， 并且 其 值 等于 给定 的 值 ， 则 执行 该  stage。expression 当 给定 的  Groovy  脚本 返回 真 时 ， 则 执行 该  stage。branch 如果 当前 使用 的 分支 名 与 指定 的 分支 名 相同 ， 则 执行 该  stage。 注意 ， 只有 在 多 分支 的  Pipeline  中 才 可以 使用 该 选项 。beforeAgent  行为 默认 情况 下 ， 当 执行 某个 带有  when  指令 的  stage  时 ，Jenkins  首先 会 进入 到 当前  stage  要 执行 的 节点 服务器 中 ， 然后 在 判断  when  指令 中 指定 的 条件 。 如果 指定  beforeAgent  为  true， 则 在 进入 到 节点 之前 就 开始 进行 判断 ， 只有 条件 符合 后 才 会 进入 到 节点 中 执行 该  stage。 示例 {{}}pipeline {    agent any    stages {        stage('Example Deploy') {            when {                beforeAgent true                branch 'production'                expression { BRANCH_NAME ==~ /(production|staging)/ }                anyOf {                    environment name: 'DEPLOY_TO', value: 'production'                    environment name: 'DEPLOY_TO', value: 'staging'                }            }            steps {                echo 'Deploying'            }        }    }}{{}} 第  5  行 ， 定义  when  指令 ， 该 指令 中共 包含  3  个 条件 ，when  指令 默认 使用  allOf， 因此 ， 只有 定义 的  3  个 条件 全部 为 真 时 ， 当前  stage Example Deploy  才 会 被 执行 。 第  6  行 ， 指定 先 对  when  中 的 条件 进行 判断 ， 只有 所有 条件 符合 后 ， 才 会 进入 到 某个 节点 中 执行  steps  操作 。 第  7  行 ， 当前 所 操作 的 分支 名 应当 为  production。 第  8  行 ， 通过  expression  指定 的 该 表达式 返回 应当 返回 真 。 第  9-11  行 ， 在  anyOf  块 中 定义 了 两个 表达式 ： 执行 的 节点 系统 中 存在 环境变量  DEPLOY_TO， 并且 该 值 必须 是  production  或  staging  中 的 一个 值 。Parallel 在  Pipeline  中 ， 默认 同时 只能 执行 一个  stage  块 ， 但 有些 时候 某些  stage  之间 没有 互相 依赖 关系 ， 我们 通常 希望 可以 并行执行 这些 互相 没有 任何 依赖 的  stage， 来 加速 整个  Pipeline  的 构建 速度 。 我们 可以 通过  Pipeline  提供 的  parallel  指令 来 实现 ， 该 指令 必须 被 包含 在  stage  块 中 ，parallel  中 不能 在 嵌套 其他 的  parallel。 注意 ， 在 定义 了  parallel  的  stage  中 ， 不 能够 在 使用 任何  agent  或  tool  等 指令 ， 如果 有 必须 ， 需要 在  parallel  中 的 每个  stage  中 进行 各自 的 定义 。 同时 ， 我们 还 可以 指定 ， 当 并行执行 的 多个  stage  中 ， 只要 有 任意 一个  stage  执行 失败 ， 就 可以 终止 所有 其他 并行执行 的  stage， 这 通过 设置  failFast true  来 实现 。 示例 {{}}pipeline {    agent any    stages {        stage('Non-Parallel Stage') {            steps {                echo 'This stage will be executed first.'            }        }        stage('Parallel Stage') {            when {                branch 'master'            }            failFast true            parallel {                stage('Branch A') {                    agent {                        label \"for-branch-a\"                    }                    steps {                        echo \"On Branch A\"                    }                }                stage('Branch B') {                    agent {                        label \"for-branch-b\"                    }                    steps {                        echo \"On Branch B\"                    }                }            }        }    }}{{}} 第  13  行 ， 指定 了  failFast true， 表明  parallel  中 定义 的  Branch A stage  和  Branch B stage  中 的 任意 一个 执行 失败 ， 另 一个 则 会 马上 停止 。 第  14  行 ， 定义 了  parralel， 并 在 其 内部 定义 了 两个 可以 同时 并行执行 的  stage：Branch A  和  Branch B。 第  16-18  行 ， 为  Branch A stage  指定 了 要 执行 的 节点 。toolspost 完整 示例 {{}}class myname{    public get() {        print('name')    }}public get() {    print('name')}String name = 'zzl'pipeline {    agent {        label 'Linux'    }    environment {        GITCOMMITTERNAME = 'jenkins'    }    options {        timeout(6, HOURS)    }    stages {        stage('Build') {            steps {            sh 'mvn clean install'            }        }        stage('Archive') {            when {                branch '*/master'            }            steps {                archive '/target//'                junit '/target/surefire-reports/.xml'            }        }    }    post {        always {            deleteDir()        }    }}{{}}Pipeline  官方 文档 2.7 pipeline  插件 ","title":"Jenkins  定义 式  Pipeline  语法 ","oriTitle":"Jenkins 定义式 Pipeline 语法"},{"uri":"/posts/linux-user","tags":["CentOS","Linux"],"content":" 用户 其实 就是 系统 中 的 账号 ， 只有 拥有 了 账号 ， 我们 才 可以 登录 到 系统 中 ， 执行 相应 的 操作 。 每个 用户 又 必须 属于 一个   主组   和 一个 或 多个   其他 组 。 用户 和 组 又 是 构成  Linux  权限 管理 的 基础 ， 因此 了解 用户 和 组 ， 对 学习  Linux  至关重要 。 本文 意在 向 大家 简单 介绍 如何 在  Linux  下 通过 命令行 的 方式 对 用户 和 组 进行 操作 。 通过 该文 的 讲解 ， 你 将 能够 掌握 到 以下 命令 ：useradd  创建 新 用户 passwd  和  chpasswd  修改 用户 密码 usermod  修改 用户 属性 chage  修改 用户 已 日期 相关 信息 userdel  删除 用户 groupadd  创建 组 groupdel 删除 组 id  查看 用户 信息 ulimit  用户 资源 限制 相关 操作 本文 所 使用 的 系统 环境 为  CentOS 7.4， 并且 所有 命令 都 运行 在  root  用户 下 ， 如果 您 没有 登录  root  用户 的 权限 ， 则 至少 有  sudo  权限 ， 并 在 所有 命令 前 使用  sudo  命令 。 用户 管理 在 这 一节 中 ， 我们 将 学习 如果 创建 新 用户 ， 查看 用户 信息 ， 修改 用 该 信息 及 密码 ， 以及 与 用户 相关 的 以为 文件 。useradd  创建 用户 在  Linux  下 ， 我们 可以 通过 命令  useradd  来 创建 一个 新 用户 ， 其 格式 为  useradd [options] LOGIN。  它 可以 接受 一个 或者 多个 参数 ， 下面 列出 了 一些 常用 的 参数 ：-d，--home HOME_DIR： 该 选项 接收 一个 路径 作为 参数 ， 用于 指定 新创建 的 用户 的  home  目录 。 如果 没有 指定 该 选项 ， 则 默认 在  /home  目录 下 创建 一个 与 用户名 同名 的 文件夹 作为 新创建 用户 的  home  目录 。-m, --create-home： 如果 系统 默认 设定 为 不 为 新 用户 创建  home  目录 时 ， 可以 使用 该 选项 明确 指定 为 用户 创建  home  目录 。 另外 ， 如果 命令行 中 同时 使用 了  -k  选项 ， 该 选项 也 必须 被 明确 指定 ， 才 会 使  -k  选项 生效 。-M： 不 为 新创建 的 这个 用户 创建 任何  home  目录 （ 默认 为 新 用户 创建  home  目录 ）。-u, --uid UID： 每个 用户 在 系统 中 都 存在 一个 唯一 的 标识号 ： UID。  当 创建 一个 新 用户 时 ， 系统 会 自动 分配 一个 当前 可用 的 最小  ID  作为 这个 用户 的  UID， 在  CentOS  下 ， 普通用户 级别 的 起始  ID  为  1000。 通过 该 选项 ， 我们 可以 为 新创建 的 用户 手动 指定 一个  UID 。 但 该  UID  必须 没有 被 使用 。-U，--user-group： 创建 一个 与 新 用户 同名 的 组 ， 并 将 该 用户 添加 到 这个 组 中 （ 默认 行为 ）。-g, --gid GROUP： 将 组  GROUP  指定 为 该 用户 的 主组 （ 主组 的 概念 将 会 在 用户组 这 一节 中 介绍 ），GROUP  可以 是 组 名 ， 也 可以 是 组  ID， 但 前提 是 该组 必须 是 已经 存在 的 组 。-G, --groups GROUP1[,GROUP2,...[,GROUPN]]： 将 新创建 的 用户 同时 加入 到 指定 的 这些 组 中 ， 各个 组 之间 使用 逗号 分隔 ， 中间 不能 含有 任何 多余 的 空格 。 同样 ， 这些 组 必须 都 是 已经 存在 的 组 。-N, --no-user-group： 不会 创建 与 用户名 同名 的 组 ， 如果 没有 指定  -g  选项 ， 则 将 该 用户 添加 到 系统 默认 组 中 。-s，--shell SHELL： 用于 指定 用户 的 登录  SHELL。 默认 为  bash-c, --comment COMMENT： 为 新创建 的 用户 添加 一些 说明 。-e, --expiredate EXPIREDATE： 指定 新 用户 的 过期 日志 ，EXPIREDATE  格式 为 ： YYYY-MM-dd-k, --skel SKELDIR： 默认 情况 下 ， 当 新 用户 被 创建 后 ，useradd  命令 会 将  /etc/skel  文件夹 下 的 文件 拷贝到 新 用户 的  home  目录 中 。 该 参数 可以 让 我们 手动 指定 拷贝  SKELDIR  目录 下 的 文件 到 新 用户 的 跟 目录 下 。 需要 注意 的 是 ， 如果 指定 了 该 选项 ， 则 必须 同时 指定  -m  选项 ， 否则 不会 生效 。 示例 创建 一个 名为  luke1  的 新 用户 ：[root@localhost ~]$ useradd luke1 默认 情况 下 ， 等同于 ：[root@localhost ~]$ useradd -m -U luke1 该 命令 将 会 执行 以下 几个 步骤 ：   创建 一个 名为  luke1。   创建 一个 与 用户名 同名 的 新 组 。   将 该 用户 的 主组 和 其他 组 全部 设定 为 这个 新 组 。   在  /home  目录 下 创建 一个  luke1  文件夹 作为  luke1  用户 的  home  目录 。 我们 可以 使用 命令  id  来 查看 用户 详细信息 ：[root@localhost ~]$ id luke1uid=1000(luke1) gid=1000(luke1) groups=1000(luke1) 通过 该 命令 ， 可以 观察 到 ， 我们 先 创建 的 用户  UID  为  1000， 新创建 的 组  ID  也 为  1000. 指定 其他 路径 作为 新创建 用户 的 根目录 为 ：[root@localhost ~]$ useradd -d /var/www/ luke2 该 命令 会 在  /var  目录 下 创建 一个  www  文件夹 ， 并 将 目录  /var/www  指定 为  luke2  用户 的 根目录 。 不 创建  home  目录 [root@localhost ~]$ useradd -M luke3 不会 为  luke3  用户 创建 根目录 ， 但 注意 ， 这 并 不 代表  luke3  用户 没有 跟 目录 ， 只是 根目录 没有 被 创建 罢了 。 指定 新创建 用户 的  UID[root@localhost ~]$ useradd -u 1005 luke4[root@localhost /]$ id luke4uid=1005(luke4) gid=1005(luke4) groups=1005(luke4) 新创建 用户 的  UID  为  1005>  注意 ： 当 我们 在 创建 一个 新 用户 时 如果 为 该 用户 指定 了  UID， 在 这 之后 创建 的 用户 的  UID  会 在 该  UID  基础 之上 进行 增加 ， 继续 看 下面 的 例子 。 指定 用户 的 主组 [root@localhost /]$ useradd -N -g 0 luke5[root@localhost /]$ id luke5uid=1006(luke5) gid=0(root) groups=0(root)-N  选项 指明 了 不会 创建  luke5  组 ， 而是 将 新 用户 添加 到  0（root）  组 下 。 事实上 ， 当 指定 了  -g  参数 时 ，-N  可以 忽略 。 同时 ， 我们 注意 到 ，luke5  用户 的  UID  为  1006， 实在  luke4  的  UID  基础 上 加  1  得到 的 。[root@localhost /]$ useradd -N luke5-b[root@localhost /]$ id luke5-buid=1007(luke5-b) gid=100(users) groups=100(users) 可以 看到 ， 新创建 的 用户  luke5-b  被 添加 到 系统 默认 用户组  users  中 。 将 新 用户 添加 到 多个 组 中 [root@localhost /]$ useradd -u 1010 -g luke1 -G luke2,luke3,luke4 -d /var/luke6/ -m luke6[root@localhost /]$ id luke6uid=1010(luke6) gid=1002(luke1) groups=1002(luke1),1003(luke2),1004(luke3),1005(luke4) 指定  luke6  主组  luke1， 该 用户 同时 属于  luke2，luke3  和  luke4  组 。 并 创建  /var/luke6/  作为 其  home  目录 。 修改  login shell[root@localhost /]$ useradd -s /bin/bash -c \"Testing user\" luke7 指定  luke7  用户 默认 的 登录  SHELL  为  bash， 并 为 该 用户 添加 了 简短 的 注释 。 指定 用户 过期 日期 [root@localhost /]$ useradd -e 2018-02-24 luke8[root@localhost /]$ chage -l luke8Last password change\t\t\t\t\t: Feb 23, 2018Password expires\t\t\t\t\t: neverPassword inactive\t\t\t\t\t: neverAccount expires\t\t\t\t\t\t: Feb 24, 2018Minimum number of days between password change\t\t: 0Maximum number of days between password change\t\t: 99999Number of days of warning before password expires\t: 7 通过  -e  选项 将 账号 过期 日志 指定 为  Feb 24, 2018， 可以 通过  chage -l username  方式 查看 账户 过期 日期 。 关于  chage  命令 的 详细 说明 ， 将 会 在 下面 小节 中 介绍 。 另 一个 例子 ： 将 新创建 账号 的 过期 日期 设置 为  300  天 之后 useradd -e date -d \"300 days\" +\"%Y-%m-%d\" luke8id  命令 查看 用户 信息 当 我们 想要 查看 某个 用户 信息 时 ， 可以 使用 命令行 工具  id， 该 命令 可以 让 我们 获取 到 用户 的 用户名 ，UID， 主组 名 及其 主组  ID， 所有 其他 组 名称 和 组  ID  等 信息 ， 其 基本 格式 为 ：id [OPTION] [USERNAME]。 其中  OPTION  和  USERNAME  均 为 可 选 参数 ， 如果 没有 指定 任何  username  参数 ， 则 获取 当前 用户 信息 。 下面 列出 了 一些 常用 的 选项 ：-u，--user： 只 显示 用户 的  UID-g，--group： 打印 出 用户 主组  ID。-G，--groups： 打印 出 用户 所有 其他 组  ID。-n，--name： 显示 用户 或 组 的 名称 ， 而 非 他们 的  ID。 示例 获取 当前 用户 的 信息 ：[root@localhost ~]# iduid=0(root) gid=0(root) groups=0(root) context=unconfinedu:unconfinedr:unconfined_t:s0-s0:c0.c1023 获取 指定 用户 的 信息 通过 在 命令行 后 指定  luke1， 来 获取 指定 用户 的 信息 ：[root@localhost ~]# id luke1uid=1001(luke1) gid=1002(luke1) groups=1002(luke1) 获取 用户  UID[luke1@promote ~]$ id -u luke11001 获取 用户 的 用户名 [luke1@promote ~]$ id -un luke1luke1 获取 用户 的 主组  ID 通过  -g  或  --group  命令 获取 到 用户 的 主组  ID：[luke1@promote ~]$ id -g luke11001 该 命令 等同于 ：id --group luke1 获取 用户 的 主组 名称 通过  -n  或  --name  获取 相应 的 名字 ， 而 非  ID  值 ：[luke1@promote ~]$ id -gn luke1luke1 获取 用户 的 其他 组  ID  和 名称 [luke1@promote ~]$ id -G luke11002[luke1@promote ~]$ id -Gn luke1luke1passwd  修改 用户 密码 当 成功 创建 好 一个 用户 后 ， 一般 都 需要 为 新创建 的 用户 设置 密码 。 可以 使用 命令行 工具  passwd  为 某个 用户 设置 密码 ， 其 格式 为 ：passwd [OPTION] [USERNAME] 其中  OPTION  和  USERNAME  均 为 可 选 参数 ， 如果 没有 指定 任何  username  参数 ， 则 为 当前 用户 设置 密码 。passwd  不仅 可以 帮助 我们 为 用户 设置 密码 ， 它 还 可以 用来 查看 和 修改 密码 日期 相关 信息 ， 比如 设置 密码 过期 日期 等 。 下面 列出 了 一些 常用 的 选项 ：-S，--status： 获取 指定 账号 的 状态 信息 。-e，--expire： 使得 某个 用户 的 密码 即可 过期 ， 这 会 强制 用户 在 下次 登录 系统 时 修改 密码 。 执行 此 命令 的 用户 需要 有 特殊 权限 。-n，--mindays MINDAYS： 设置 两次 密码 修改 的 最小 间隔 天数 为  MINDAYS。0  表示 没有 限制 。-x，--maxdays MAXDAYS： 设置 密码 的 有效 天数 为  MAXDAYS， 当 超过  MAX_DAYS  天时 ， 密码 将 过期 。-1  表示 密码 永不 过期 。-w，--warndays WARNDAYS： 设置 密码 过期 前  WARNDAYS  天 ， 用户 开始 收到 报警 信息 。-i，--inactive INACTIVE： 设置 当 密码 过期  INACTIVE  天数 后 ， 账号 将 被 锁定 。 被 锁定 的 账号 将 无法 登录 到 系统 中 。-1  表示 永不 锁定 账号 。-l，--lock： 锁定 指定 账号 的 密码 。-u，--unlock： 解锁 某个 使用  -l  选项 锁定 的 账号 。-d，--delete： 删除 指定 用户 的 密码 。 被 删除 密码 的 用户 将 无法 登陆 系统 。 示例 修改 当前 用户 密码 如果 直接 执行  passwd  命令 而 不 加 任何 参数 ， 系统 将 提示 用户 修改 当前 用户 的 密码 。 对于  root  用户 来说 ， 修改  root  密码 不 需要 提供 当前 密码 ， 而 对于 普通用户 来说 ， 需要 提供 当前 密码 才能 当前 用户 密码 。root  用户 直接 输入 新密码 即可 ：[root@localhost ~]# passwdChanging password for user root.New password: 对于 普通用户 ， 需要 先 提供 用户 的 当前 密码 ：[luke1@promote ~]$ passwdChanging password for user luke1.Changing password for luke1.(current) UNIX password: 特权 用户 修改 其他 用户 密码 拥有 特权 的 用户 除了 可以 修改 自己 密码 之外 ， 还 可以 修改 其他 用户 密码 ， 只 需 在  passwd  命令 后 指定 要 修改 的 用户名 即可 ：[root@localhost ~]# passwd luke1Changing password for user luke1.New password: 通过 这种 方式 为 其他 用户 修改 密码 ， 同样 不 需要 提供 用户 的 当前 密码 。 获取 用户 账户 信息 使用  -S  可以 获取 指定 用户 的 账号 信息 ， 返回 的 信息 共 包含  7  个 字 段 ， 他们 分别 为 ： 用户 的 登录名 。 密码 状态 信息 ， 包括 以下 几种 状态 ：  LK：  表示 账号密码 被 锁定 ；  NP：  表示 没有 为 该 账号 设置 密码 ；  PS：  表示 密码 被 正确 设置 了 ； 上次 修改 密码 的 时间 。 两次 密码 修改 的 最小 间隔 天数 。 密码 多少 天 之后 过期 。 密码 过期 前 多少 天 开始 报警 。 密码 过期 几天 后 帐号 会 被 锁定 。 密码 状态 的 描述 说明 。[root@localhost ~]# passwd -S luke1luke2 PS 2018-02-26 0 99999 7 -1 (Password set, MD5 crypt.) 通过 上面 的 输出 ， 我们 可以 得出 以下 结论 ：luke1  账号密码 被 正确 地 使用  MD5  设置 设置 过 了 ； 设置 密码 的 日期 为  2018-02-26； 账号  luke1  对 两次 密码 修改 时间 的 间隔 没有 任何 限制 ， 并且 设置 了 密码 用 不过 期 ； 账号密码 会 在 过期  7  天 开始 报警 （ 这里 该 账号密码 用 不过 期 ， 因此 该 值 没有 意义 ）； 即使 密码 过期 后 也 不会 锁定 该 账号 。 强制 用户 密码 过期 使用  -e  选项 强制 账户  luke1  的 密码 过期 ， 当下 次 使用 该 账户 登录 系统 时 ， 将 提示 用户 修改 密码 。[root@localhost ~]# passwd -e luke1 删除 账号密码 使用  -d  删除 账号  luke1  的 密码 ， 删除 密码 后  luke1  用户 将 无法 登录 到 系统 中 ：[root@localhost ~]# passwd -d luke1Removing password for user luke1.passwd: Success[root@localhost ~]# passwd -S luke1luke1 NP 2018-02-26 1 99999 45 5 (Empty password.) 锁定 账号密码 通过  -l  选项 锁定 账号  luke1  的 密码 。 锁定 账号密码 并 不 影响 账号 的 登录 ， 仅仅 是 使 账号 的 密码 不可 用 。 用户 仍然 可以 使用 其他 方式 ， 比如  SSH  秘 钥 的 方式 登录 到 系统 中 。[root@localhost ~]# passwd -l luke1Locking password for user luke1.passwd: Success[root@localhost ~]# passwd -S luke1luke1 LK 2018-02-26 1 99999 45 5 (Password locked.) 解锁 账号密码 使用  -u  选项 可以 解锁 一个 通过  -l  选项 锁定 的 账户 的 密码 ：[root@localhost ~]# passwd -u luke1Unlocking password for user luke1.passwd: Success[root@localhost ~]# passwd -S luke1luke1 PS 2018-02-26 1 99999 45 5 (Password set, MD5 crypt.) 设置 两次 密码 修改 的 最 短 间隔 设置 账户  luke1  两次 密码 修改 最 短 间隔 为  2  天 ：[root@localhost ~]# passwd -n 2 luke1Adjusting aging data for user luke1.passwd: Success[root@localhost ~]# passwd -S luke1luke1 PS 2018-02-26 2 99999 45 5 (Password set, MD5 crypt.) 设置 密码 过期 时间 设置 账户  luke1  密码 的 过期 时间 在  90  天 以后 ：[root@localhost ~]# passwd -x 90 luke1Adjusting aging data for user luke1.passwd: Success[root@localhost ~]# passwd -S luke1luke1 PS 2018-02-26 2 90 45 5 (Password set, MD5 crypt.) 对于 没有特权 的 普通用户 来说 ， 直接 在 命令行 输入  pwasswd  命令 后 ， 对于 有 超级 权限 的 用户 来说 ， 比如  root， 不但 可以 修改 自己 账户 的 当 执行 如果  passwd  命令 后 没有 跟 如果 直接 在 命令行 中 输入  passwd  命令 ， 将 会 提示 修改 当前 用户 的 passwd  命令 不仅 可以 帮助 我们 为 用户 重置 密码 ， 它 还 可以 修改 用户 密码 的 过期 日期 。 在 脚本 中 修改 用户 密码 passwd  采用 的 是 交互式 的 方式 来 修改 用户 密码 ， 但 很多 时候 我们 会 使用 脚本 的 方式 创建 账号 并 设置 密码 ， 交互式 命令 并 不能 满足 我们 的 要求 。 这时 可以 使用  --stdin  参数 指定 标准 输入 ， 而 不是 提示 用户 输入 密码 ， 在 通过 管道 的 方式 将 密码 传递 个  passwd  命令 ：[root@localhost ~]# echo \"password\" | passwd --stdin luke1Changing password for user luke1.passwd: all authentication tokens updated successfully. 对于 某些 没有 为  passwd  命令 提供  --stdin  参数 的 系统 来说 ， 还 可以 使用  chpasswd  命令 来 代替 ：[root@localhost ~]# echo \"luke1:password\" | chpasswdusermod  更新 用户 信息 usermod  命令 可以 帮助 我们 修改 系统 中 已经 存在 的 用户 的 属性 信息 ， 比如 修改 用户 的 登录名 ，home  目录 ， 组 信息 ， 登录  SHELL  等 。 其 格式 为  usermod [options] LOGIN。 下面 列出 了 一些 常用 的 选项 ：-l, --login NEWLOGIN： 更新 用户 的 登录名 为  NEWLOGIN。 注意 ， 该 选项 并 不会 修改 用户 的  home  目录 和  mail  文件 。-u, --uid UID：-d, --home HOMEDIR： 修改 用户 的  home  目录 至  HOMEDIR， 该 选项 只是 简单 将 用户 的  home  目录 指向 新 的 目录 ， 而 原  home  目录 中 的 内容 不会 被 迁移 到 新 的  home  目录 中 ， 可以 使用  -m  选项 对 原  home  目录 中 的 内容 进行 迁移 。-m, --move-home： 将 当前  home  目录 中 的 内容 迁移 到 新 的  home  目录 下 。 该 选项 必须 与  -d  选项 一起 使用 。-L, --lock： 锁定 用户 的 密码 。 该 选项 与  passwd -l  命令 效果 一样 。-U, --unlock： 解锁 用户 密码 。 该 选项 与  passwd -u  命令 效果 一样 。-g, --gid GROUP： 将 用户 的 主组 设置 为  GROUP。GROUP  可以 是 组 名 ， 也 可以 是 组  ID， 但 必须 是 系统 中 已经 存在 的 组 。 修改 用户 的 主组 ， 用户  home  目录 中 所有 文件 的 所属 组 也 将 同样 被 修改 为 该 新 组 ， 而 对于  home  目录 之外 的 文件 ， 需要 用户 手动 进行 修改 。-G, --groups GROUP1[,GROUP2,...[,GROUPN]]]： 将 用户 的 其他 组 设置 为 指定 的 新 组 。 同样 ， 提供 的 参数 可以 是 组 名 ， 也 可以 是 组  ID。 但 这些 组 必须 是 系统 中 的 有效 组 。-a, --append： 与  -G  一起 使用 ， 将  -G  指定 的 组 追加 到 当前 用户 的 其他 组 中 ， 而 不是 替换 当前 用户 的 其他 组 。-e, --expiredate EXPIREDATE： 设置 用户 的 账号 过期 日期 为  EXPIREDATE， 日期 格式 为 ：YYYY-MM-DD。 可以 通过 指定  EXPIRE_DATE  的 值 为  -1  禁用 账号 过期 功能 。  >  注意 ，usermod -e  命令 用来 设置 用户 的 账号 过期 日期 ， 而  passwd -x  用来 设置 用户 的 密码 过期 日期 。 账号 过期 的 用户 将 无法 登录 到 系统 中 ， 而 密码 过期 的 用户 仍然 可以 登录 到 系统 中 ， 并且 登录 系统 是 会 强制 用户 修改 密码 。-f, --inactive INACTIVE： 设置 账号密码 过期  INACTIVE  天 后 账号 将 被 锁定 。0  表示 密码 过期 时 账号 立即 被 锁定 ；-1  表示 不 锁定 账号 。-s, --shell SHELL： 将 用户 的 登录  SHELL  修改 为 新 值  SHELL。-c, --comment COMMENT： 修改 用户 说明 信息 。 示例 修改 用户 账号 的 说明 信息 选项  -c  用来 修改 指定 账号 的 说明 信息 ， 比如 为  luke1  用户 增加 说明 信息 ：[root@promote ~]# usermod -c \"This is Luke1\" luke1 当 设置 成功 后 ， 可以 通过 查看  /etc/passwd  文件 获取 该 信息 ， 关于 该 文件 的 说明 ， 会 在 下面 的 小节 中 介绍 到 。[root@promote ~]# getent passwd luke1luke1:x:1001:1002:This is Luke1:/home/luke1:/bin/bash 更新 用户  home  目录 使用  -d  选项 将 用户 的  home  路径 指向  /var/www  路径 。 并 通过  -m  选项 将 原 目录 下 的 文件 移动 到 新  home  路径 下 。[root@promote ~]# usermod -m -d /var/www luke1 如果 没有 指定  -m  选项 ， 则 仅仅 是 将  home  目录 指向 新 目录 ， 原 目录 中 的 文件 并 不会 被 迁移 到 新 路径 下 。 设置 账号 的 过期 日期 选项  -e  用来 更新 账户 的 过期 日期 ， 日期 格式 为  YYYY-MM-DD。 账号 日期 相关 信息 可以 通过  chage  命令 查看 ， 我们 将 会 在 下 节 详细 介绍  chage  命令 。 在 更改 账号 过期 日期 前 ， 先 让 我们 查看 一下 当前 用户  luke1  日期 相关 信息 ：[root@promote ~]# chage -l luke1Last password change\t\t\t\t\t: Feb 27, 2018Password expires\t\t\t\t\t: neverPassword inactive\t\t\t\t\t: neverAccount expires\t\t\t\t\t\t: neverMinimum number of days between password change\t\t: 2Maximum number of days between password change\t\t: -1Number of days of warning before password expires\t: 45Account expires  字 段 描述 了 账户 过期 时间 ， 当前 账户  luke1  没有 设置 任何 过期 时间 。 现在 让 我们 将  luke1  用户 的 账号 过期 日期 设置 为  2019-01-01：[root@promote ~]# usermod -e 2019-01-01 luke1[root@promote ~][root@promote ~]# chage -l luke1Last password change\t\t\t\t\t: Feb 27, 2018Password expires\t\t\t\t\t: neverPassword inactive\t\t\t\t\t: neverAccount expires\t\t\t\t\t\t: Jan 01, 2019Minimum number of days between password change\t\t: 2Maximum number of days between password change\t\t: -1Number of days of warning before password expires\t: 45 修改 用户 主组 选项  -g  用来 修改 用户 的 主组 ， 在 修改 前 首先 用  id  命令 查看  luke1  用户 信息 。[root@promote ~]# id luke1uid=1001(luke1) gid=1002(luke1) groups=1002(luke1)luke1  用户 当前 主组 为  luke1， 更新 主组 信息 ：[root@promote ~]# usermod -g 0 luke1[root@promote ~]# id luke1uid=1001(luke1) gid=0(root) groups=0(root),1002(luke1)luke1  用户 的 主组 被 更新 为  root  组 。>  当 修改 用户 主组 后 ， 用户  home  目录 下 的 所有 文件 的 所属 组 都 将 被 更新 为 新 的 组 。 向 用户 其他 组 中 追加 新 组 选项  -G  用来 修改 用户 的 其他 组 信息 ， 如果 没有 指定  -a  参数 ， 则 将 指定 的 组 代替 当前 用户 的 其他 组 信息 ； 如果 同时 指定 了  -a  选项 ， 则 将 指定 的 组 追加 到 用户 的 其他 组 信息 中 。[root@promote ~]# usermod -aG luke2 luke1[root@promote ~]# id luke1uid=1001(luke1) gid=0(root) 1002(luke1),1003(luke2) 锁定 与 解锁 用户 当 我们 想要 禁用 某个 账户 时 ， 可以 使用  -L  选项 来 锁定 该 账户 ：[root@promote ~]# usermod -L luke1>  注意 ：  被 锁定 的 账户 将 无法 登录 到 系统 中 被 锁定 的 的 账户 可以 通过  -U  选项 解锁 ：[root@promote ~]# usermod -U luke1 修改 用户 的 登录  SHELL 选项  -s  可以 帮助 我们 修改 用户 的 登录  SHELL：usermod -s /bin/zsh luke1chage  修改 用户 日期 设定 在 前面 的 小节 中 ， 我们 介绍 了 如果 使用  passwd  命令 和  usermod  命令 修改 用户 账号 日期 相关 信息 ， 比如 密码 过期 日期 、 账号 过期 日期 、 密码 修改 最小 间隔时间 等 。 虽然 这 两个 命令 可以 满足 我们 大部分 的 需求 ， 但  Linux  还是 提供 了 更 专业 的 命令行 工具  chage， 来 查看 和 修改 与 账户 日期 相关 的 信息 。 其 基本 格式 为 ：chage [options] LOGIN。 下面 列出 了 一些 常用 的 选项 ：-l, --list： 打印 出 给定 账户 相关 信息 。-M, --maxdays MAXDAYS： 设置 密码 有效期 天数 为  MAXDAYS  天 。 当 超过 指定 的 天数 后 ， 用户 再次 登录 系统 时 将 强制 用户 修改 密码 。 值  MAX_DAYS  为  -1  表示 密码 永不 过期 。-E, --expiredate EXPIREDATE： 设置 用户 的 账号 过期 日期 ， 其 值  EXPIREDATE  可以 使  YYYY-MM-DD  格式 的 日期 ， 也 可以 是 自  1970-01-01  以来 到 过期 日期 的 天数 。 值  EXPIRE_DATE  为  -1  表示 永不 过期 。-I, --inactive INACTIVE： 设置 账号密码 过期  INACTIVE  天 后 ， 账号 将 被 锁定 。-1  表示 关闭 此 功能 。-m, --mindays MINDAYS： 设置 两次 修改 密码 最少 需要 间隔  MINDAYS  天 。-W, --warndays WARNDAYS： 设置 密码 过期 前  WARNDAYS  天 系统 开始 提示 警告 信息 。-d, --lastday LASTDAY： 手动 修改 上次 密码 的 修改 日期 ， 其 值  EXPIREDATE  可以 使  YYYY-MM-DD  格式 的 日期 ， 也 可以 是 自  1970-01-01  以来 上次 修改 密码 的 天数 。 如果 指定  LAST_DAY  的 值 为  0， 则 用户 在 下次 登录 系统 时 将 强制 该 用户 修改 密码 。>  注意 ： 再次 提醒 ， 用户 的 账号 过期 与 用户 的 密码 过期 不同 。 当 账号 过期 后 ， 用户 将 无法 登录 到 系统 中 ； 当 密码 过期 后 ， 用户 仍然 可以 登录 到 系统 中 ， 只是 在 登录 系统 时 ， 系统 会 强制 用户 修改 当前 密码 。 示例 修改 用户 账号 的 过期 日期 在 修改 用户 的 账号 过期 日期 之前 ， 首先 通过  -l  选项 查看  luke1  账号 在 修改 前 的 信息 ：[root@localhost ~]# chage -l luke1Last password change\t\t\t\t\t: Feb 27, 2018Password expires\t\t\t\t\t: neverPassword inactive\t\t\t\t\t: neverAccount expires\t\t\t\t\t\t: Jan 01, 2019Minimum number of days between password change\t\t: 2Maximum number of days between password change\t\t: -1Number of days of warning before password expires\t: 45 从 输出 中 可以 看出 ， 用户 的 账号 过期 日期 为  2019/1/1。 现在 ， 让 我们 使用  -E  选项 为  luke1  用户 重新 设置 账号 过期 日期 ：[root@localhost ~]# chage -E -1 luke1[root@localhost ~][root@localhost ~]# chage -l luke1Last password change\t\t\t\t\t: Feb 27, 2018Password expires\t\t\t\t\t: neverPassword inactive\t\t\t\t\t: neverAccount expires\t\t\t\t\t\t: neverMinimum number of days between password change\t\t: 2Maximum number of days between password change\t\t: -1Number of days of warning before password expires\t: 45luke1  账号 的 过期 日期 被 成功 设置 为了 永不 过期 。 设置 用户 的 密码 过期 时间 从 上面 例子 中 获取 到 的 信息 中 ， 我们 可以 看到 ， 当前 用户  luke1  的 密码 被 设置 为了 永不 过期 。 这里 ， 我们 将 通过  -M  参数设置 该 用户 密码 每次 最 多 保留  90  天 ， 当  90  天 过后 ， 用户 密码 将 过期 。[root@localhost ~]# chage -M 90 luke1[root@localhost ~][root@localhost ~]# chage -l luke1Last password change\t\t\t\t\t: Feb 27, 2018Password expires\t\t\t\t\t: May 28, 2018Password inactive\t\t\t\t\t: Jun 02, 2018Account expires\t\t\t\t\t\t: neverMinimum number of days between password change\t\t: 2Maximum number of days between password change\t\t: 90Number of days of warning before password expires\t: 45 同时 修改 多项 下面 ， 我们 将 尝试 同时 修改 多项 ：[root@localhost ~]# chage -I -1 -m 0 -M 99999 -E -1 luke1 在 这个 例子 中 ， 我们 设置 了 账号 用 不过 期 ； 两次 密码 修改 间距 天数 不 受限制 ； 用户 密码 用 不过 期 ； 即使 密码 过期 ， 账户 也 永不 过期 。userdel  删除 用户 当 某个 用户 不 在 使用 时 ， 我们 应当 将 该 用户 从 系统 中 移 除掉 。 可以 使用  userdel  名 来 来 删除 某个 用户 。 基本 格式 为 ：userdel [options] LOGIN。 下面 列出 了 一些 常用 的 选项 ：-f, --force： 强制 删除 用户 ， 即使 被 删除 的 用户 当前 处于 登录 状态 ； 同时 该 选项 也 会 强制 删除 用户 的  home  目录 和  mail  文件 ， 即使 还有 其他 用户 使用 同样 的 目录 作为  home  目录 。-r, --remove： 移除 账户 时 ， 同时 删掉 该 账户 的  home  目录 ， 及其 所有  mail  文件 。 默认 保留 这些 文件 。 示例 ： 删除 用户 [root@localhost /]$ userdel luke8[root@localhost /]$ id luke8id: luke8: no such user 用户  luke8  已经 不 在 存在 了 。 删除 用户 的 同时 ， 删除 其 对 用 的  home  目录 和  mail 在 上面 的 例子 中 ， 我们 仅仅 是 删除 了  luke8  用户 ， 但 其  home  目录  /home/luke8/  及其  mail  文件 并 没有 被 移除 [root@localhost /]$ ls -l /home/luke8/total 0 通过  ls  命令 ， 我们 仍然 可以 访问 到  luke8  用户 的  home  目录 。 如果 想要 在 删除 用户 时 ， 同时 将 他 的  home  目录 一起 删掉 ， 可以 在  userdel  命令 中 指定  -r  选项 [root@localhost /]$ useradd luke8useradd: warning: the home directory already exists.Not copying any file from skel directory into it.Creating mailbox file: File exists[root@localhost /]$ userdel -r luke8[root@localhost /]$ ls -l /home/luke8ls: cannot access /home/luke8: No such file or directory 我们 首先 重新 创建  luke8 user， 系统 会 返回 一些 警告 信息 ， 提示  luke8  用户 要 使用 的  home  目录 已经 存在 了 ， 这里 可以 直接 忽略 警告 。 接着 在 删除 用户 时 指定  -r  参数 ， 再次 查看  luke8  用户 的  home  目录 ， 此时 已经 不 存在 了 。-r  选项 不仅 会 删除 用户 的  home  目录 ， 同时 也 将 用户 的  mail  文件 一并 删除 掉 。 用户 相关 的 系统文件 /etc/default/useradd 在 创建 用户 那 一节 中 ， 我们 直接 使用 命令  useradd luke1  创建 一个 名为  luke1  的 新  user， 虽然 我们 没有 指定  -m  和  -U  参数 ， 系统 仍然 为 我们 创建 了  /home/luke1  目录 作为 该 用户 的  home  目录 ， 并且 同时 创建 了 一个 同名 的 组 作为 该 用户 的 主组 。 这 是因为 系统 为 我们 提供 了 一组 默认 的 行为 ， 当 我们 创建 新 用户 时 ， 如果 忽略 了 某些 选项 ， 则 系统 会 使用 这些 默认 行为 来 协助 我们 创建 用户 。 这些 默认值 保存 在  /etc/default/useradd  中 。 让 我们 通过  cat  命令 来 查看 该 文件 中 的 内容 ：[root@localhost ~]# cat /etc/default/useradduseradd defaults fileGROUP=100             #  如果 创建 用户 时 指定 了  -N， 并且 没有 指定  -g， 则 默认 使用 组  ID  为  100  的 组 作为 新 用户 的 主组 HOME=/home            #  默认 在  /home  目录 下 创建 用户  home  目录 INACTIVE=-1           #  默认 账户 不过 期 EXPIRE=               #  默认 不 设置 密码 过期 天数 SHELL=/bin/bash       # /bin/bash  作为 用户 的 默认  SHELLSKEL=/etc/skel        #  默认 将  /etc/skel  下 的 所有 文件 拷贝到 新 用户 的  home  目录 下 CREATEMAILSPOOL=yes #  默认 创建 用户 的  mail spool/etc/passwd 当 一个 用户 尝试 登录 系统 时 ， 系统 首先 会 查看  /etc/passwd  文件 ， 该 文件 保存 了 当前 系统 中 所有 用户 的 信息 。 每当 我们 新创建 一个 新 用户 时 ， 也 会 在 该 文件 中 追加 一条 记录 。 同样 ， 当 修改 或 删除 某个 用户 时 ， 也 会 更新 该 文件 。 因此 ， 我们 可以 将 文件  /etc/passwd  看做 是 系统 中 用户 保存 用户 信息 的 数据库 文件 。/etc/passwd  是 一个 文本文件 ， 系统 中 的 任何 一个 用户 都 可以 查看 它 的 内容 ， 但 只有  root  用户 可以 修改 它 的 内容 。 可以 通过  cat  命令 直接 查看 该 文件 内容 ：[root@localhost ~]# cat /etc/passwd...luke7:x:1011:1011:Testing user:/home/luke7:/bin/bash... 也 可以 借助  getent  命令 的 子 命令  passwd  来 获取 全部 或 指定 的 某 条 用户 记录 信息 ， 如 ：[root@localhost ~]# getent passwd luke7luke7:x:1011:1011:Testing user:/home/luke7:/bin/bash>  如果 不 指定  luke7， 则 打印 出 全部 用户 信息 。 每 条 用户 记录 在 文件 中 占用 一行 ， 并且 由 多个 字 段 组成 ， 各个 字 段 之间 使用 冒号 （:） 分隔 ， 其 格式 为 ： 用户名 ： 用户 的 登录名 。Password： 密码 占位 符  X， 它 并 不是 用户 真正 的 密码 。 该 字 段 是 历史 遗留下来 的 ， 真正 的 密码 被 保存 在  /etc/shadow  文件 中 。 用户  ID(UID)： 每个 用户 在 系统 中 都 有 一个 唯一 的 标识  ID。 其中  root ID  为 0，1~99  为 系统 保留  ID。 自定义 用户 起始  ID  为  1000， 每 创建 一个 新 用户 ， 其  UID  在 上 一个  UID  基础 上 依次 累加  1。 组  ID(GID)： 用户 所属 的 主组 。 用户 注释 ： 创建 用户 时 通过  -c  选项 为 用户 指定 的 注释 信息 。Home  目录 ： 用户 的  home  目录 。 当 使用 一个  home  目录 没有 被 创建 的 用户 登录 系统 是 ， 目录 会 被 自动 切换 到 系统 根目录  /  下 。 当 用户 登录 系统 是 自动 执行 的 命令 ： 它 通常 指向 一个  shell。 可以 通过 将 该项 指定 为  /bin/false  来 禁止 用户 进行 登录 操作 。 当 我们 尝试 修改 该  /etc/passwd  内容 时 ， 最好 是 使用 命令  vipw  来 修改 ， 而 不是 使用 一般 的 编辑器 工具 。 该 命令 可以 在 我们 修改 该 文件 时 自动 加入 文件 锁 ， 防止 多用户 同时 修改 造成 冲突 。 另外 ， 如果 我们 手动 修改 了 这些 文件 ， 一定 要 保证 修改 后 的 文件 和 用户 信息 的 正确性 ， 任何 一点 小 错误 都 可能 导致用户 无法 正确 登录 到 系统 中 。 检查 是否 有 错误 最 简单 的 办法 是 使用  pwck  命令 。 直接 在 命令行 中 输入  pwck  命令 ， 可以 打印 出 任何 需要 修复 的 问题 。/etc/shadow/etc/shadow  是 另 一个 比较 重要 的 文件 ， 它 存储 了 所有 用户 的 密码 信息 和 密码 过期 时间 等 信息 。[root@localhost ~]# cat /etc/shadow...luke1:$1$L936UA7E$03ZIw90xe.0f4cZO.MBiJ.:17586:0:99999:7:::... 该 文件 只有  root  用户 有 查看 权限 ， 与  /etc/passwd  类似 ， 文件 中 的 每 一行 都 是 一条 单独 的 记录 ， 每 条 记录 中 又 包含 了 多个 字 段 。 下面 对 各个 字 段 进行 了 简单 的 描述 ： 用户 的 登录名 。 密码 字 段 。 该 字 段 可能 有 以下 几种 值 ：    空值 ， 表明 当前 用户 登录 密码 为 空 ；    星号 代表 帐号 被 锁定 ；    双 叹 号 表示 这个 密码 已经 过期 了 ；   $1$  表明 是 用 MD5 加密 ；   $2$  是 用 Blowfish 加密 ；   $5$  是 用  SHA-256 加密 ；   $6$  开头 的 ， 表明 是 用 SHA-512 加密 ； 密码 最后 修改 时间 ， 其 值 为 距  1970.1.1  号 到 密码 修改 那天 的 天数 。 两次 密码 修改 的 最小 天数 间隔 。0 表示 没有 限制 。 密码 最 多 可以 使用 的 天数 ， 即 多少 天 后 密码 过期 。 密码 过期 前 多少 天 开始 提示 警告 信息 。 密码 过期 多少 天 后 账号 将 被 禁用 距离  1970.1.1  号 多少 天 后 账号 将 被 禁用 最后 一个 字 段 为 保留字 段 ， 没有 被 使用 。 组 管理 在  Linux  系统 中 ， 有 两种 类型 的 组 ： 主组   和   其他 组 。 每个 用户 都 必须 有 且 只能 有 一个 主组 ， 并且 至少 属于 一个 其他 组 。 当 新创建 一个 用户 时 ， 如果 没有 通过  -g  参数 为 这个 用户 指定 一个 主组 ， 系统 则 会 自动 创建 一个 与 用户名 同名 的 组 ， 并 将 新创建 的 组 设置 为 该 用户 的 主组 。 主组 与 其他 组 最 重要 的 却 别 在于 ， 当 用户 创建 一个 新 文件 时 ， 文件 所属 的 组 为 用户 的 主组 ， 并且 ， 没有 任何 主组 的 用户 ， 将 无法 登录 到 系统 中 ； 而 对 用 用户 的 其他 组 来说 ， 当 用户 操作 一个 不 属于 自己 的 文件 ， 且 文件 所属 组 不是 当前 用户 的 主组 时 ， 但 该 用户 属于 该 文件 所属 组 下 的 成员 ， 即 该 用户 的 其他 组 中 包含 文件 所属 的 组 ， 则 该 用户 可以 以 组 的 权限 来 操作 该 文件 。groupadd  创建 组 虽然 创建 用户 时 ， 系统 可以 帮助 我们 同时 创建 对应 的 组 ， 但 总 有些 时候 ， 我们 需要 手动 创建 一些 组 。Linux  系统命令  groupadd  就是 用来 创建 新 组 的 ， 他 的 基本 格式 为 ：groupadd [options] group。 下面 列出 了 一些 常用 的 选项 ：-g, --gid GID：  将 值  GID  做 为 新创建 组 的 组  ID。-f, --force： 当 重复 创建 一个 系统 中 已经 存在 的 组 时 ，groupadd  命令 将 直接 退出 ， 并且 将 命令 的 执行 结果 设置 为 失败 。-f  选项 将 通知 系统 ， 即使 创建 一个 已经 存在 的 组 时 ， 命令 也 将 返回 成功 。 示例 创建 组 时 指定 组  ID 每个 组 都 有 一个 系统 唯一 的 标识符   组  ID（GID）， 当 创建 组 时 ， 系统 将 默认 分给 一个  ID  做 为 新创建 组 的 组  ID。 我们 可以 通过 使用  -g  参数 ， 为 新创建 的 组 指定 一个 自定义 的 组  ID。 下面 示例 展示 了 如何 创建 一个组  ID  为  11000  的 新 组  grouptesting：[root@localhost ~]# groupadd -g 1100 grouptesting 强制 创建 新 组 在 上面 的 命令 中 ， 我们 创建 了 一个 名为  grouptesting  的 新 组 ， 如果 再次 尝试 创建 一个 同名 的 组 ， 则 将 提示 错误 ， 同时 命令 返回 失败 ：[root@localhost ~]# groupadd grouptestinggroupadd: group 'grouptesting' already exists[root@localhost ~]# echo $?9 可以 看到 ，groupadd  命令 的 返回值 为  9， 表示 该组 已经 存在 ， 命令 执行 失败 。 使用  -f  参数 ：[root@localhost ~]# groupadd -f grouptesting[root@localhost ~]# echo $?0 当 我们 指定 了  -f  参数 后 ，groupadd  命令 的 返回值 为 0， 表示 执行 成功 。 查看 组 信息 groups  命令 可以 用来 获取 指定 用户 的 组 信息 ， 如果 没有 指定 登录 用户 ， 则 获取 当前 用户组 信息 ， 如 ：[root@localhost ~]# groupsroot[root@localhost ~][root@localhost ~]# getent group luke1luke1:x:1002:luke1 可以 使用  getent group  命令 获取 某个 组 的 信息 ， 如 ：[root@localhost ~]# getent group luke1luke1:x:1002:luke1 如果 没有 指定 组 名 ， 则 获取 当前 系统 中 的 所有 组 信息 。groupmod  修改 组 信息 groupmod  命令 可以 用来 修改 一个 已经 存在 的 组 ， 其 格式 为 ： groupmod [options] GROUP。 下面 列出 了 一些 常用 的 选项 ：-g, --gid GID： 修改 组  ID，-n, --new-name NEW_GROUP： 更新 组 名 示例 更新  grouptesting  组 名为  grouptest， 同时 修改 它 的 组  ID：[root@localhost ~]# groupmod -n 1200 -g grouptestgroupdel  删除 组 当 某个 组 不 在 使用 时 ， 我们 应当 使用 系统命令  groupdel  删除 这个 组 ， 并 将要 删除 的 组 名 作为 参数传递 给 该 命令 。>  注意 ： 我们 无法 删除 某个 仍然 作为 其他 用户 主组 的 组 。 下面 例子 展示 了 如何 删除 我们 刚刚 创建 的 新 组  grouptesting：[root@localhost ~]# groupdel grouptesting>  注意 ： 当 删除 某个 组 之后 ， 任何 所属 组 为 被 删除 组 的 文件 的 组 信息 都 将 失效 ， 同时 显示 为 被 删除 组 的 组  ID。 组 相关 的 系统文件 /etc/group 系统 中 所有 组 的 信息 全部 保存 在  /etc/group  文件 中 ， 与 用户 信息 一样 ， 每 条 组 记录 在 文件 中 占用 单独 一行 ， 记录 一共 有 3 个 字 段 ， 分别 为   组 名 、 组 密码 占位 符  X  组  ID  以及 。 可以 使用  cat  命令 直接 查 该 文件 内容 ：[root@localhost ~]# cat /etc/group 也 可以 借助  getent  命令 的 子 命令  group  来 获取 全部 或 指定 的 某 条 组 记录 信息 ， 如 ：[root@localhost ~]# getent group rootroot:x:0:: 很多 系统 还 提供 了 更加 高级 的  adduser  命令 ， 而 在  CentOS 7  中 ，adduser  则 是 以  useradd  命令 的 软 连接 的 形式 存在 的 。","title":"Linux  用户 和 组 ","oriTitle":"Linux 用户和组"},{"uri":"/posts/python-metaclass","tags":["Python"],"content":"Metaclass  作为  Python  中 的 一种 高级 用法 ， 开发人员 平时 很少 会 直接 使用 到 它 。 然而 一旦 我们 真正 掌握 了  metaclass， 不仅 会 让 我们 编写出 更 高效 的 代码 ， 而且 会 对  Python  中 的 类 会 有 更加 深刻 的 理解 。 在 介绍  Metaclass  之前 ， 先 让 我们 看 一下  Python  中 的 类 。Python  中 的 类 相信 大家 对 类 的 概念 并 不 陌生 ， 我们 通常 将 类比 作为 蓝图 ， 实例 化 类 就 指 是 根据 这个 蓝图 ， 创建 出 一个个 具体 的 实例 来 。 也 可以 理解 为 ， 类 就是 用来 创建 类 实例 对象 的 ：{{}}class MyClass():    passmy_obj = MyClass()print(my_obj)>>>{{}} 在 这 段 代码 中 ， 我们 创建 了 一个 类 的 实例 对象 ， 并 让 变量  myobj  指向 这个 新创建 的 实例 对象 ， 最终 成功 打印 出 了 这个 对象 。 类  MyClass  可以 看做 是 创建 实例 对象  myobj  的   材料 。 类 也 是 对象 在  Python  中 ， 类 不仅仅 可以 用来 创建对象 的 ， 同时 ， 类 本身 也 是 一个 对象 （ 这 也 符合  Python  中 一切 皆 对象 的 说法 ）。 这 意味着 我们 可以 ：   将 类 赋值 给 一个 变量    拷贝 类    将 类 作为 参数传递 给 其他 类 或 方法    为 类 添加 属性 {{}}my_class = MyClassprint(my_class)>>>def print_obj(obj):    print(obj)print_obj(MyClass)>>>print(hasattr(MyClass, 'new_attribute'))>>> FalseMyClass.new_attribute = 'foo'print(hasattr(MyClass, 'new_attribute'))>>> True{{}} 代码 解析 ： 第  1  行 中 我们 将 类 赋值 给 变量  my_class,  并 成功 地 打印 出 了 这个 类 。 第  8  行 中将 类 作为 参数 ， 传递 给  print_obj  函数 。 第  14  行 中 ， 动态 为 类 添加 新 属性 。 既然 类 本身 也 是 作为 一个 对象 存在 的 ， 那么 它 也 一定 是 通过 某些   材料   被 创建 出来 的 ， 那么 创建 类 的 材料 又 是 什么 呢 ？ 答案 是  type。type  关键字 你 一定 不会 对  Python  中 的  type  关键字 感到 陌生 ， 我们 通常 向 它 传递 一个 对象 作为 唯一 的 参数 ， 来 返回 这个 对象 的 类型 ， 例如 ：{{}}>>> type(1)>>> type('string')>>> type(()){{}} 如果 我们 继续 对  Python  内置 的 类型 进行  type  操作 ， 会 发生 什么 呢 ？{{}}>>> type(int)>>> type(str)>>> type(tuple){{}} 会 发现 他们 的 类型 全部 是  type。 对 我们 刚刚 定义 的 类  MyClass  进行 同样 的  type  测试 ：{{}}>>> type(MyClass){{}} 其 结果 也 是  type，  这 说明 这些 内置 类型 ， 包括 我们 自定义 的  MyClass  类 ， 全部都是 通过  type  创建 出来 的 ， 这 又 是 为什么 呢 ？ 使用  type  动态创建 类 type  不仅仅 可以 用来 判断 某个 对象 的 类型 ， 它 还有 另 一个 鲜为人知 的 强大 功能 ， 就是 用来 创建 类 ， 其 格式 为 ：type(name, bases, dict)>  这 是 典型 的 多态性 ， 根据 不同 的 参数 ， 其 行为 也 随之 不同 。 它 一共 接受 三个 参数 ：name:  字符串 类型 ， 指定 了 我们 要 创建 的 类 的 名称 。base  元组 类型 ， 指定 了 新创建 类 的 所有 父 类 ， 如果 无需 继承 任何 父 类 ， 则 传递 一个 空 元组 。attrs  字典 类型 ， 指定 了 新创建 类 中 的 所有 属性 ， 如果 不 包含 任何 属性 ， 则 传递 一个 空 字典 。 下面 ， 我们 通过 一个 简单 的 例子 ， 创建 一个 不 包含 任何 属性 的 空类 ：{{}}MyClass = type('MyClass', (), {}){{}} 我们 使用  type  关键字 创建 了 一个 名为  MyClass  的 类 ， 这个 类 没有 继承 任何 父 类 ， 也 不 包含 任何 属性 和 方法 ， 并 将 这个 类 赋 给 变量  MyClass， 使 其 这个 变量 指向 我们 刚刚 创建 的 类 。>  注意 ： 这里 我们 使用 了 相同 的 名字  MyClass  同时 作为 类 名 和 变量名 ， 这 并 不是 必须 的 ， 但 为了 减少 疑惑 ， 提升 代码 可读性 ， 尽量 采用 统一 的 名字 。 上面 的 代码 完全 等价 于 我们 使用  class  关键字 创建 的 类 ：class MyClass():    pass 这 就是 为什么 当 我们 使用  type(MyClass)  时 ， 返回 的 结果 为  type  类型 ， 这 也 是  Python  创建 类 的 默认 方式 。 现在 ， 让 我们 看 一个 更 复杂 一点 的 例子 :{{}}def get_name(self):    return self.namedef init(self, name):    self.name = nameMyClass = type('MyClass', (object,), {'getname':getname, 'init':init})my_obj = MyClass('zzl')print(myobj.getname())>>> zzl{{}} 在 这个 例子 中 ， 我们 使用  type  关键字 创建 了 一个 包含 有 两个 方法 的 类  MyClass： 第  1  行 和 第  4  行 分别 定义 了 两个 函数  get_name  和  init，  这里 需要 注意 的 是 ， 每个 函数 都 至少 需要 接收 一个 名为  self  的 参数 作为 第一个 参数 ， 因为 这 两个 函数 都 将要 作为 类 中 的 方法 来 被 调用 。 第  7  行 中 ， 指定 它 继承 的 父 类 为  object  对象 ， 并 将 类 中 的 属性 名 和 对应 的 值 ，  通过 字典 的 方式 作为 第三个 参数传递 给  type。 通过 这 段 代码 ， 我们 创建 了 一个 名为  MyClass  的 类 ， 类 中 含有 两个 方法 ， 一个 是 构造方法  init， 和 一个 普通 方法  get_name。>  细心 的 你 可能 已经 发现 了 ， 我们 为  init  变量 赋予 了 一个 不同 的 名 的 函数  init， 这 是 完全 可以 的 。Python  中 的 类 正是 通过 这种 方式 被 创建 出来 的 。 元 类 （Metaclass） 前 文中 ， 我们 提及 过  type  是 创建 类 的 默认 材料 ， 更 准确 的 来说 ， 元 类 （Metaclass） 才 是 创建 类 的 材料 ， 即 类 都 是 通过 元 类 被 创建 出来 的 ， 而  Python  中 默认 的 元 类 就是  type。 自定义 元 类 除了 使用  Python  中 默认 的 元 类  type  外 ， 我们 还 可以 自己 实现 自定义 的 元 类 。 事实上 ， 任何 可 调用 对象 都 可 作为 元 类 ， 它 可以 是 一个 函数 ， 也 可以 是 一个 类 ， 我们 只 需 确保 该 可 调用 对象 接收 与  type  创建 类 时 所 使用 的 相同 的 三个 参数 ， 并 最终 返回 一个 类 即可 。 让 我们 分别 看 一下 当 函数 和 类 作为 元 类 时 的 情况 。1. 函数 作为 元 类 考虑 这样 一种 情况 ， 当 我们 创建 一个 类 时 ， 无论是 类 中 的 属性 名 还是 方法 名 ， 最终 我们 都 想 将 它们 转化 为 大写 形式 ， 这时 ， 我们 就 可以 使用  Metaclass  来 创建 我们 的 类 ， 在  Metaclass  中 获取 到 类 中 所有 用户 自定义 的 属性 ， 并 将 它们 的 名字 转换成 大写 即可 。{{}}def upperattr(futureclassname, futureclassparents, futureclass_attr):    uppercase_attr = {}    for name, val in futureclassattr.items():        if not name.startswith('__'):            uppercase_attr[name.upper()] = val        else:            uppercase_attr[name] = val 调用  type  来 创建 我们 需要 的 类     return type(futureclassname, futureclassparents, uppercase_attr) 通过  upper_attr  创建  MyClass  类 类 中 包含 一个 名为  foo  的 属性 MyClass = upper_attr('MyClass', (), {'foo':'bar'})print(hasattr(MyClass, 'foo'))  #  Falseprint(hasattr(MyClass, 'FOO'))  #  Trueprint(MyClass.FOO) #  bar{{}} 代码 解释 ： 第  1  行 ， 我们 首先 定义 了 一个 函数 ， 该 函数 接收 三个 参数 ， 分别 作为 要 创建 类 的 类 名 ， 父 类 及 类 中 的 属性 传递 给 该 函数 。 第  2  行 ， 定义 一个 全局 字典 ， 用于 保存 将 属性 名 转换成 大写 后 的 所有 类 中 的 属性 。 第  5  行 ， 将 用户 自定义 的 属性 名 转换成 大写 ， 并 保存 到 全局变量  uppercase_attr  中 。 第  10  行 ， 最终 还是 通过 调用  type  来 创建 出 我们 的 新 类 并 返回 给 调用者 。 后面 我们 会 看到 其他 不用  type  方式 来 返回 类 对象 的 方法 。 第  14  行 ， 与  type  用法 一样 ， 这里 我们 通过 自定义 的  Metaclass  来 创建 类 ， 并 为 该类 设定 了  foo  属性 。 第  18  行 ， 能够 正确 访问 类 中 的  FOO  属性 ， 说明 属性 名 已经 被 转换成 大写 形式 了 。 这 是 一个 没有 什么 意义 的 例子 ， 但是 通过 这个 例子 ， 可 让 让 我们 对 元 类 有 一个 基本 的 理解 。2. 类 作为 元 类 虽然 可以 将 函数 作为 元 类 来 创建 类 ， 但 创建 一个 类 作为 元 类 来 使用 ， 这 将 更 符合  OOP  思想 ， 并且 有 更 多 的 灵活性 。 需要 注意 的 是 ， 当 使用 类 作为 元 类 时 ， 必须 注意 以下 两点 ： 类 的 最 顶层 必须 继承 自  type： 虽然 是 元 类 ， 但 它 同时 还是 一个 类 ， 这 就 说明 作为 元 类 的 类 也 可以 继承 ， 但 就 像是  object  类 是 所有 类 的 最 顶级 父 类 一样 ，type  必须 是 元 类 的 最 顶级 元 类 。 按 要求 实现  new  方法 ：new  方法 体内 是 用来 实现 真正 创建 类 的 代码 块 的 ， 该 方法 除了 第一个 参数 是 类 本身 之外 ， 同样 还 需 额外 的 其他 三个 参数 ：name, bases  以及  attrs  来 创建 类 。 现在 让 我们 通过 类 作为 元 类 来 实现 上面 的 例子 ， 将 类 中 所有 的 用户 自定义 属性 的 名字 转换成 大写 ：{{}}class UpperAttr(type):    _uppercaseattr = {}    def new(cls, futureclassname, futureclassparents, futureclassattr):        for name, val in futureclassattr.items():            if not name.startswith('__'):                cls._uppercaseattr[name.upper()] = val            else:                cls._uppercaseattr[name] = val 通过 调用  super  返回 类         return super(UpperAttr, cls).new(            cls,            futureclassname,            futureclassparents,cls._uppercaseattr        )MyClass = UpperAttr('MyClass', (), {'foo':'bar'})print(MyClass.FOO) #  bar{{}} 代码 解释 ： 第  1  行 ， 创建 一个 继承 自  type  的 类 ， 元 类 的 最终 父 类 必须 要 继承 自  type。 第  2  行 ， 定义 私有 类 变量 ， 用于 保存 属性 名 转换 为 大写 之后 的 所有 属性 第  4  行 ， 实现 了  new  方法 ， 它 一共 接收  4  个 参数 ： 由  Python  自动 传递 类 自身 参数  cls， 以及 其他 三个 用来 创建 类 的 参数 ， 该 方法 最终 必须 返回 一个 类 对象 。 第  10-15  行 ， 这里 使用  super  方法 ， 而 不是 直接 调用  type， 虽然  Python  最终 还是 通过 调用  type  来 生成 类 的 ， 但 这种 写法 更加 符合  OOP  编程 思想 ， 也 更加 灵活 ， 比如 下面 将 会 看到 的 ， 自动 调用  init  方法 等 。 第  17  行 ， 使用 元 类  UpperAttr  来 创建 类 我们 的 类 ， 其 调用 方法 与 调用函数 元 类 和  type  类似 。 第  18  行 ， 访问  MyClass  类 中 的  FOO  属性 。 元 类 中 的  init  和  call 通过 类 实现 的 元 类 ， 本身 又 是 一个 类 ， 因此 类 中 的 其他 魔术 方法 ， 同样 可以 应用 在 我们 的 这个 元 类 中 ， 下面 让 我们 看 一下 两个 常用 的 魔术 方法 在 元 类 中 的 应用 ：init： 与 正常 类 中 的 使用 方式 一样 ， 如果 在 元 类 中 定义 了 该 方法 ， 当  new  返回 后 ， 会 自动 调用 该 方法 。call： 若 在 元 类 中 定义 了  call  方法 ， 那么 该 方法 会 在 被 创建 的 类   被 实例 化   时 自动 调用 ， 我们 通常 将 它 应用 到 单 例 模式 的 创建 中 去 ， 考虑 如下 实例 ：{{}}class MetaSingleton(type): 类 属性 ， 用来 保存 实例 对象 设置 为 类 私有 属性 ， 防止 被 意外 修改     __instance = None    def call(cls, args, *kvargs): 如果 类 属性  __instance  不 为 空 ， 说明 已经 实例 化 过 某个 类 ， 直接 返回 那个 类 实例 即可 如果 为  None， 则 创建 一个 新 的 实例 对象 ， 并 保存 到  __instance  变量 中         if cls.__instance is None:            cls.instance = super(MetaSingleton, cls).call__(args, *kvargs) 总是 返回 类 属性  __instance        return cls.__instance 通过  MetaSingleton  元 类 创建 类 SingletonKls = MetaSingleton('SingletonKls', (), {}) 创建 类 实例 my_obj1 = SingletonKls()my_obj2 = SingletonKls() 打印 出 实例  ID，  两次 返回值 一样 print(id(my_obj1))print(id(my_obj2)){{}} 代码 解释 ： 第  1  行 ： 定义 元 类  MetaSingleton， 并 继承 自  type。 第  6  行 ： 定义  call  方法 ， 该 方法 会 在 实例 化 类 时 被 调用 。 第  10  行 ： 如果 类 属性  __instance  为  None， 才 创建 新 的 类 实例 ， 否则 返回 之前 已经 创建 过 的 类 实例 。 第  16  行 ： 通过 元 类  MetaSingleton  创建 我们 的 类 。 第  19  行 ： 由于 实例 是 第一次 被 实例 化 ， 调用 第  10  行 创建 新 的 实例 ， 并 将 实例 保存 在 了 元 类 中 的  __instance  属性 中 。 第  20  行 ： 由于 此时 元 类 的 类 属性  __instance  已经 保存 了 刚刚 生成 的 实例 对象 ， 所以 直接 将 上次 创建 的 实例 返回 回来 。 正确 使用 元 类 的 姿势 虽然 我们 可以 使用  kls = Metaclass(name, bases, attrs)  的 方式 使用 元 类 来 生成 我们 的 类 ， 但 这种 方式 不仅 丑陋 难 用 ， 而且 非常 不 符合  OOP  标准 ， 正确 的 使用 方式 是 ： 在 我们 使用  class  关键字 定义 类 时 ， 明确 指定 我们 要 使用 的  Metaclass。 在  Python2  和  Python3  中 ， 指定  Metaclass  的 方式 是 不同 的 ， 让 我们 分别 看 一下 如何 在 两个 版本 中 分别 使用  Metaclass。Python2 在  Python2  中 ， 通过 在 类 中 设定  metaclass  属性 来 指定 我们 要 使用 的 元 类 ， 如 ：{{}}class MyClass(object):    metaclass = MetaSingleton{{}}Python3 在  Python3  中 ， 声明  Metaclass  是 在 类 名 后面 的 括号 中 ， 通过 关键字  metaclass  来 指定 的 ：{{}}class MyClass(metaclass=MetaSingleton): pass{{}} 如果 类 同时 还 继承 自 其他 类 ， 则  metaclass  放在 继承 类 的 后面 ， 并用 逗号  ,  分隔 ， 如 ：{{}}class MyClass(ParentClass, metaclass=MetaSingleton):    pass{{}}{{}}Python2  与  Python3  中 的 声明 语法 是 不同 的 ， 并且 互不 兼容 ， 如果 想 编写 跨平台 的 代码 ， 可以 引用 第三方  Pyhton  库  six{{}} 元 类 的 继承性 当 我们 继承 一个 指明 了 元 类 的 类 ， 而 自身 并 没有 指明 任何 元 类 ， 会 发生 什么 呢 ？{{}}class Animal(metaclass=MetaSingleton): passclass Dog(Animal): pass 实例 化 两个  Dog  类 dog1 = Dog()dog2 = Dog()print(id(dog1)) #  4370179968print(id(dog2)) #  4370179968{{}} 这 是 一个 不 太 恰当 的 例子 ， 但是 足以 说明 问题 了 ： 第  1  行 ， 首先 我们 创建 了 一个  Animal  的 类 ， 并 为 该类 指定 了 我们 的 元 类  MetaSingleton。 第  2  行 ， 声明 一个  Dog  类 ， 继承 自  Animal  类 。 实例 化 两个  Dog  类 ， 最终 打印 出 这 两个 实例 的  ID 从 结果 中 可以 看出 ， 他们 是 同一个 实例 对象 ， 虽然  Dog  并 没有 指明 元 类 ， 但是 由于 它 的 父 类  Animal  指明 了  MetaSingleton  元 类 ， 对于 子类  Dog  来说 ， 该 属性 被 继承 了 下来 ， 也就是说 ， 此时  Dog  的 元 类 也 是  MetaSingleton。{{}} 在 定义 类 时 ， 每个 类 只能 声明 一次  metaclass， 而 无论  metaclass  是 在 父 类 中 声明 的 ， 还是 在 自身 类 定义 时 声明 的 ， 否则  Python  解释器 会 抛出  TypeError  异常 ， 提示  metaclass  冲突 错误 。{{}}Metaclass  是 如何 工作 的 ？ 当 我们 通过 直接 调用 元 类 的 方式 创建 类 时 ， 意图 很 明确 ， 我们 将 所有 创建 类 所 需要 的 数据 通过 参数 的 方式 传递 给 元 类 。 而 通过  class  方式 声明 的 类 ，Python  有时 如何 解释 的 呢 ？ 当  Python  解释器 遇到  class  关键字 时 ， 首先 扫描 类 的 内部 定义 ， 包括 类 变量 和 内部 定义 的 所有 方法 ， 并 将 扫描 的 信息 保存 到  dict  字典 中 ， 此刻 ， 在 内存 中 ， 类 还 没有 被 创建 ； 解释器 接着 会 查看 类 的 定义 中 是否 声明 了  metaclass， 如果 存在  metaclass  的 声明 ， 则 调用 我们 声明 的  metaclass ， 并 将 类 名 、 父 类 以及  dict  传递 给 它 来 创建 类 ， 否则 将 这些 信息 传递 给  type  来 创建 类 ， 并 最终 保 将 类 保存 到 内存 中 。 结束语 通过  Metaclass  能够 实现 的 大部分 功能 ， 其实 通过 其他 方法 一般 也 可以 实现 。 何时 需要 使用  Metaclass， 需要 视 具体情况 而 定 ， 为了 代码 的 可读性 和 维护性 ， 在 非必要 的 情况 下 ， 能 避免 使用  Metaclass  则 尽量避免 使用 。 参考 : stack overflow  中 的 神 级 回答 ","title":"Python  中 的  Metaclass","oriTitle":"Python 中的 Metaclass"},{"uri":"/posts/python-requests","tags":["Python"],"content":"requests  是 一个 款 基于  urllib3  开发 的  HTTP  开源 库 ， 该 库 为 我们 提供 了 丰富 的  HTTP  请求 相关 函数 ， 主要 功能 包括 ： 支持 发送 多种类型 的 请求 ， 包括  GET、POST、PUT、DELETE、OPTIONS、HEAD、PATCH。 支持 连接池 ， 提升 效率 。 其 提供 的  session  模块 能够 自动 保存 并 处理  cookies  等 信息 ， 大大 节约 开发成本 。 支持 基本 的  HTTP  认证 功能 。 支持 文件 上传下载 等 功能 。 支持  SSL 支持  HTTP  代理 由于 该 库 简单 ， 高效 ， 功能齐全 等 特性 ， 被 众多 大 厂商 所 青睐 。 本文 意在 向 读者 简单 介绍 该 库 的 一些 基本 用法 ， 在 阅读 本文 时 ， 推荐 读者 参考 该 库 的 官方 文档 一起 学习 。 安装 requests  库 并 不 属于  Python  的 内置 库 ， 因此 在 使用 前 ， 需要 手动 安装 ， 可以 使用  pip  命令 直接 安装 ：pip install requests 当 安装 成功 后 ， 就 可以 在 代码 中 引用 该 库 了 ：import requests 发送 请求 对于  HTTP  库 来说 ， 最 基本 的 功能 就是 发送  HTTP  请求 ，requests  库 提供 了 多种 发送 请求 的 方法 ， 分别 用于 支持  HTTP  协议 中 定义 的 不同   请求 类型 ， 这些 请求 类型 包括 ：GET、POST、PUT、DELETE、HEAD、OPTIONS、PATCH 等 ， 下面 让 我们 依次 介绍 如何 使用  requests  库 来 发送 这些 请求 。GET  请求 首先 ， 让 我们 看 一下  GET  请求 。HTTP GET  方法 被 设计 成 用于 获取 某个 特定 资源 信息 的 ， 通常 用于 检索 数据 。requests  库 中 提供 的  get  方法 可以 用来 向 某个 服务器发送 一个  GET  请求 。 其 方法 原型 为 ：get(url, params=None, **kwargs)。 其中 ：url  为 必选 参数 ， 接收 一个 字符串 类型 的 值 ， 指明 要 发送 请求 的  URL  地址 。params  为 可 选 参数 ， 指定 发送 请求 时 的 附加 数据 。**kwargs  为 一些 其他 可 选 参数 ， 在 后面 的 讲解 中 会 依次 引入 介绍 。 该 方法 返回 一个  Response  对象 。 接下来 让 我们 看 一个 具体 的 示例 ， 通过  Github API  来 获取 某个 特定 用户 的 信息 ：>>> r = requests.get('https://api.github.com/users/gbyukg') 在 这个 示例 ， 我们 使用 了  get  方法 向  https://api.github.com/users/gbyukg  地址 发送 了 一个  GET  请求 ， 并 将 返回 的  Response  对象 保存 到 了 变量  r  中 ， 通过 调用  Response  对象 提供 的  text  方法 ， 可以 获取 到  HTTP  请求 响应 体 中 的 内容 ：>>> r.text>>> '{\"login\":\"gbyukg\",\"id\":36716,...}'>  注意 ：text  被 定义 成 了 属性 函数 ， 因此 调用 时 没有 在 该 方法 结尾 添加  ()。 向  GET  请求 中 发送数据 很大 一部分 情况 ， 当 我们 向 某个 服务器发送 一个  GET  请求 的 同时 ， 还 需要 向 服务器 传递 一些 附加 的 数据 信息 。get  方法 支持 两种 方式 来 发送 这些 附加 数据 ： 在  URL  中 指定 附加 数据   和   通过  params  参数传递 。 下面 让 我们 依次 了解 这 两种 发送数据 的 方式 。 通过  URL  发送数据 当 我们 在 浏览器 中 访问 某个 需要 传送 附加 数据 的 请求 时 ， 需要 将 这些 附加 数据 追加 到 服务器  URL  地址 中 去 ， 例如 访问  http://httpbin.org/get?key1=value1&key2=value2  时 ， 会 同时 将 附加 数据  key1=value1  和  key2=value2  传送 到 服务器 中 。 下面 是 当 我们 在 浏览器 中 打开 该 地址 时 的 返回 结果 ：{  \"args\": {    \"key1\": \"value1\",    \"key2\": \"value2\"  },  ...} 通过 将 数据 附加 到  URL  地址 中 的 方式 ， 同样 适用 于  get  方法 ， 如 ：>>> r = requests.get('http://httpbin.org/get?key1=value1&key2=value2')>>> r.text>>> '{\\n  \"args\": {\\n    \"key1\": \"value1\", \\n    \"key2\": \"value2\"\\n  },... } 可以 看到 ， 在  args  中 同样 返回 来 这 两个 附加 参数 。 使用  params  参数传递 请求 数据 除了 将 所 要 传递 的 参数 附加 到  URL  地址 中外 ， 我们 还 可以 将 这些 参数 以 字典 的 方式 传递 给  get  方法 的  params  参数 ， 如 ：>>> payload = {'key1': 'value1', 'key2': 'value2'}>>> r = requests.get('http://httpbin.org/get', params=payload)>>> r.text>>> '{\\n  \"args\": {\\n    \"key1\": \"value1\", \\n    \"key2\": \"value2\"\\n  },... } 获取 到 的 响应 体 与 上面 例子 完全相同 。 查看  Response  对象 的  url  属性 来 获取 最终 发送 请求 的  URL  地址 ：>>> r.url>>> http://httpbin.org/get?key2=value2&key1=value1 可以 发现 ，get  方法 实际上 就是 将 这些 参数 解析 后 保存 到 了  URL  地址 中 ， 并 最终 以 第一个 示例 中 的 方式 发送给 服务器 。 有些 时候 ， 在 要 发送 的 数据 中 ， 可能 一个 键值 对应 多个 要 传递 的 值 ， 如 在  URL http://httpbin.org/get?key1=value1&key2=value2&key2=value3  中 ，key2  分别 对应  value2  和  value3  两个 值 ， 当 以 字典 的 方式 传递 给  params  参数 ， 可以 将 这 两个 值 保存 到 一个 可 迭代 对象 中 传递 给  key2  键 ，requests  库 会 自动 为 我们 处理 这种 含有 多个 值 的 情况 ， 如 ：>>> # key2  的 值 是 一个 元组 >>> payload = {'key1': 'value1', 'key2': ('value2', 'value3')}>>> r = requests.get('http://httpbin.org/get', params=payload)>>> r.text>>> # key2  中 此时 包含 了 两个 值 >>> '{\\n  \"args\": {\\n    \"key1\": \"value1\", \\n    \"key2\": [\\n      \"value2\", \\n      \"value3\"\\n    ]\\n  } ... }>>> r.url>>> 'http://httpbin.org/get?key1=value1&key2=value2&key2=value3'>  其中 ，key2 的 值 也 可以 使用 列表 代替 。POST  请求 HTTP POST  方法 被 设计 成 用于 向 服务器 特定 资源 发送数据 的 ， 通常 用于 创建 或 更新 服务器 中 的 资源 。requests  库 中 提供 的  post  方法 可以 用来 向 某个 服务器发送 一个  POST  请求 。 其 方法 原型 为 ：post(url, data=None, json=None, **kwargs)。 其中 ：url  为 必选 参数 ， 字符串 类型 ， 指明 要 发送 请求 的  URL  地址 。data  为 可 选 参数 ， 指定 发送 请求 时 的 附加 数据 ， 该 值 可以 是 以下 类型 ：   字典 类型 ： 字典 中 每个 元素 都 将 作为 一个 参数传递 给 服务器 ， 其中 每个 元素 的 键 作为 要 发送数据 的  key， 值 作为 要 发送数据 的 值 ；   元组 类型 ： 如果 是 元组 类型 ， 则 元组 中 的 每个 元素 必须 是 一个 包含 有 两个 元素 的 元组 ， 每个 元组 中 的 两个 元素 分别 作为 要 传递数据 的 键 和 值 ；   字符串 型 ： 如果 是 字符串 类型 ， 则 必须 是 能够 被 正确 转换成  JSON  格式 的 字符串 ；json  为 可 选 参数 ，JSON  格式 的 字符串 类型 ， 指定 发送 请求 时 的 附加 数据 。**kwargs  为 一些 其他 可 选 参数 ， 在 后面 的 讲解 中 会 依次 引入 介绍 。 与  get  方法 一样 ， 该 方法 返回 一个  Response  对象 。 虽然  GET  请求 可以 向 服务器端 发送数据 ， 但  POST  是 专门 被 设计 成 用来 向 服务器发送 附加 数据 的 请求 的 ，post  方法 支持 两个 传送 附加 数据 的 参数 ， 下面 让 我们 看 一下 如何 使用 这 两个 参数 。data  参数 post  方法 可以 将 我们 传递 给  data  参数 的 值 作为 附加值 发送给 我们 所 请求 的 服务器 。 该 参数 可以 接收  3  种 不同 类型 的 值 ， 分别 是 ： 字典 类型 、 元组 类型 和 字符串 类型 。 字典 类型 当 传递 给  data  参数 一个 字典 时 ， 字典 的 键 和 值 将 分别 作为 被 发送数据 的 名称 和 所 对应 的 值 ， 如 ：>>> r = requests.post('http://httpbin.org/post', data = {'key':'value'})>>> r.json()>>>{  'args': {},  'data': '',  'files': {},  'form': {    'key': 'value' #  以 字典 的 方式 传递 给  data  参数 的 数据   },  ...} 在 这个 例子 中 ， 我们 使用 了  response  对象 的  json  方法 来 获取 消息 体 中 的 内容 ， 该 方法 会 将 返回 的 数据 转换成  Python  对应 的 数据类型 ， 这里 使用  json  方法 ， 主要 是 其 输出 格式 方便 我们 观察 。 在 返回 的 数据 中 ， 可以 看到 ， 我们 传送 的 数据 被 保存 到 了  form  字 段 中 。 与  get  方法 类似 ， 也 可以 将 一个 除 字符串 之外 的 可 迭代 对象 作为 字典 中 某个 元素 的 值 ， 为 要 发送 的 某个 数据 提供 多个 值 ：payload = {'key1': 'value1', 'key2': ('value2', 'value3')}r = requests.post('http://httpbin.org/post', data=payload)r.json(){  'args': {},  'data': '',  'files': {},  'form': {    'key1': 'value1',    'key2': [ #  同时 传递 多个 值 给  key2      'value2',      'value3'      ]    },  ...} 元组 / 列表 等 可 迭代 对象 类型 我们 还 可以 将 一个 元组 或 列表 等 可 迭代 对象 传递 给  data  参数 ， 其中 该 对象 中 的 每个 元素 又 是 一个 含有 两个 元素 的 元组 或 列表 对象 ， 这 两个 元素 分别 作为 附加 数据 的 名称 和 值 ， 如 ：>>> # payload = [['key1', 'value1'], ['key1', 'value2']]>>> # payload = [('key1', 'value1'), ('key1', 'value2')]>>> # payload = (['key1', 'value1'], ['key1', 'value2'])>>> # payload = (('key1', 'value1'), ('key1', 'value2'))>>> #  通过 这  4  种 方式 传递 的 数据 效果 完全相同 >>> payload = (('key1', 'value1'), ('key1', 'value2'))>>> r = requests.post('http://httpbin.org/post', data=payload)>>> r.text{  ...  \"form\": {    \"key1\": [      \"value1\",      \"value2\"    ]  },  ...} 字符串 类型 最后 一种 方式 是 直接 将 一个 字符串 传递 给  data  参数 ：>>> r = requests.post('http://httpbin.org/post', data=\"{key1: 'value1'}\") 或是 通过  json  模块 将  Python  对象 转换成 字符串 对象 ：>>> import json>>> r = requests.post('http://httpbin.org/post', data=json.dumps({'key1': 'value1'})) 获取  HTTP  响应 内容 ：>>> r.json()>>>{  'args': {},  'data': \"{key1: 'value1'}\",  ...  'form': {},  ...} 细心 的 你 可以 已经 发现 了 ， 当 我们 通过 字典 和 元组 传递 参数 时 ， 在 返回 的  HTTP  响应 体 中 ， 这些 参数 被 保存 到 了  form  字 段 中 ， 而 当 我们 使用 字符串 类型 传递 参数 时 ， 数据 被 保存 到 了  data  字典 中 。 虽然 这 是  httpbin  服务器 有意 而 为 之 ， 但 这 也 真实 地 反映 出 了 服务器端 在 接收 到 请求 时 这些 附加 参数 被 保存 的 位置 信息 ， 为什么 这些 附加 数据 会 保存 在 不同 的 位置 呢 ？ 这 是因为 当 传递 给  data  一个 字典 或是 元组 时 ，request  会 自动 向 请求 头 中 添加  Content-Type:application/x-www-form-urlencoded  头 信息 ， 这样 会 将 我们 传递 的 数据 自动 转换成  form  表单 编码数据 （ 即 就 像是 通过 提交  form  表单 时 发送 的 请求 那样 ）;  而 当 我们 直接 传递 一个 字符串 类型 时 ，request  不会 做 任何 转换 。 我们 可以 通过 返回 的  response  对象 的  request.headers  来 获取 发送 的  HTTP  请求 头 信息 ， 如 ：>>> #  首先 发送 一个 字典 作为  data  参数值 的  POST  请求 >>> r = requests.post('http://httpbin.org/post', data = {'key':'value'})>>> #  获取 请求 头 信息 >>> r.request.headers>>> #  默认 为 我们 添加 了  'Content-Type': 'application/x-www-form-urlencoded'  头 >>> {'User-Agent': 'python-requests/2.18.4', 'Accept-Encoding': 'gzip, deflate', 'Accept': '/', 'Connection': 'keep-alive', 'Content-Length': '9', 'Content-Type': 'application/x-www-form-urlencoded'}>>> #  接着 发送 一个 以 字符串 作为  data  参数值 的  POST  请求 >>> r = requests.post('http://httpbin.org/post', data=\"{key1: 'value1'}\")>>> r.request.headers>>> {'User-Agent': 'python-requests/2.18.4', 'Accept-Encoding': 'gzip, deflate', 'Accept': '/', 'Connection': 'keep-alive', 'Content-Length': '16'}json  参数 除了 使用  data  传递数据 之外 ，post  方法 还 提供 了 另外 一个 参数  json  来 传递数据 ， 如 ：>>> url = 'http://httpbin.org/post'>>> payload = {'some': 'data'}>>> r = requests.post(url, json=payload)>>> r.json()>>>{'args': {},  'data': \"{some: 'data'}\",  ...  'form': {},  ...  } 使用  json  参数 来 向 服务器发送 数据 时 ，requests  库 会 自动 将 头 信息  Content-Type:application/json  添加 到  HTTP  请求 头 中 ， 通常 我们 在 返回 的 消息 体 中 是  JSON  格式 的 字符串 时 使用 这种 头 信息 ， 如 访问  Github API  服务器 。>>> r.request.headers>>> {'User-Agent': 'python-requests/2.18.4', 'Accept-Encoding': 'gzip, deflate', 'Accept': '/', 'Connection': 'keep-alive', 'Content-Length': '16', 'Content-Type': 'application/json'}>  注意 ： 如果 同时 指定 了  data  和  json  参数 ， 则  json  参数 将 被 忽略 。PUT  请求 HTTP  的  PUT  方法 被 设计 成 用来 替换 当前 服务器 中 已有 资源 的 ， 通常 用于 将 新 的 资源 来 替换 某个 已有 的 资源 。requests  库 中 提供 的  put  方法 用来 发送 一个  PUT  请求 。 其 方法 原型 为  put(url, data=None, **kwargs)。 除了 不 接受  json  参数 外 ， 该 方法 与  post  方法 完全 一样 。 下面 示例 展示 了 通过  put  方法 发送  PUT  请求 ：>>> #  使用 字典 作为 参数 >>> r = requests.put('http://httpbin.org/put', data = {'key':'value'})>>> r.json()>>>{  'args': {},  'data': '',  'files': {},  'form': {    'key': 'value' #  以 字典 的 方式 传递 给  data  参数 的 数据   },  ...}>>> #  使用 字符串 作为 参数 >>> r = requests.put('http://httpbin.org/put', data = \"{'key':'value'}\")>>> r.json()>>>{  'args': {},  'data': \"{key1: 'value1'}\",  ...  'form': {},  ...}PATCH  请求 HTTP PATCH  方法 被 设计 成 用于 更新 服务器 某个 资源 的 部分 信息 。requests  库 中 的  patch  方法 可 用于 向 服务器发送 一个  PATCH  请求 。 其 方法 原型 为 ： patch(url, data=None, **kwargs)。 除了 不 接受  json  参数 外 ， 该 方法 与  post  方法 完全 一样 。 示例 ：>>> r = requests.patch('http://httpbin.org/patch', data = {'key':'value'})>>> r.json()>>>{  'args': {},  'data': '',  'files': {},  'form': {    'key': 'value'  },  ...}DELETE  请求 HTTP DELETE  方法 被 设计 成 用于 从 服务器端 删除 某个 资源 。requests  库 中 的  delete  方法 用于 向 服务器发送 一个  DELETE  请求 。  其 方法 原型 为 ：delete(url, **kwargs)。 示例 ：>>> r = requests.delete('http://httpbin.org/delete')HEAD  请求 HTTP HEAD  方法 被 用来 设计 成 获取 查询  HTTP  响应 头 信息 的 ，HEAD  方法 不会 返回 任何 响应 体 信息 。requests  库 中 的  head  方法 用来 向 某个 服务器发送 一个  HEAD  请求 。 其 方法 原型 为 ：head(url, **kwargs)。 示例 ：>>> r = requests.head('http://httpbin.org/get')>>> r.headers>>>  当 我们 尝试 去 读 >>> r.json()OPTIONS  请求 除了 可以 发送  GET  请求 和  POST  请求 外 ，requests  库 还 提供 了 发送 其他 请求 类型 的 方法 ， 包括  PUT，DELETE，HEAD  和  OPTIONS  等 请求 ， 如 ：{{}}r = requests.put('http://httpbin.org/put', data = {'key':'value'})r = requests.delete('http://httpbin.org/delete')r = requests.head('http://httpbin.org/get')r = requests.options('http://httpbin.org/get'){{}}request  方法 request  方法 是 上述 所有 发送 请求 方法 的 根基 方法 ， 即 所有 方法 最终 都 是 通过 调用  request  方法 来 实现 的 。 其 方法 原型 为 ：request(method, url, **kwargs)， 该 方法 可以 接收 多个 参数 ， 下面 列出 了 所有 可用 参数 ：method： 指明 要 发送 请求 的 类型 ， 其 值 可以 是  get、post、put、delete、head、options。url： 发送 请求 的  URL  地址 params： 当  method  参数 指定 为  get  时 使用 data：json：header：cookies：files：auth：timeout：allow_redirects：proxies：verify：stream： 默认 情况 下 ， 当 一个 请求 结束 后 ，requests  会 读取 所有  HTTP  响应 体 中 的 信息 到 内存 中 ， 如果 指定 该 选项 值 为  True， 则 返回 一个  socket  流 ， 只有 在 需要 时 ， 才 真正 读取 响应 体 中 的 内容 。 对于 处理 返回 结果 中 包含 了 大量 数据 的 情况 ， 会 节省 更 多 内存 和 时间 。cert：Response  对象 无论 使用 那种 方法 发送 请求 ， 最终 都 将 返回 一个  response  对象 。response  对象 是  requests  内置 类  Response  的 一个 实例 ，response  对象 里 包含 了 所有 的  HTTP  响应 信息 ， 包括 获取 响应 体 ， 响应 头 信息 ，HTTP  状态 码 ，cookies  信息 等 ， 我们 将 依次 对 这些 属性 进行 讲解 。 获取 响应 体 内容 在 上面 的 例子 中 ， 我们 已经 使用 过 了  response  的  text  方法 来 获取  HTTP  响应 信息 体 ， 其实 ，request  不止 是 提供 了 这 一个 方法 来 获取 获取 响应 体 信息 ， 下面 让 我们 一次 了解 一下 这些 方法 。text 方法 text  是 一个 属性 函数 ， 当 我们 尝试 使用 该 方法 来 读取  HTTP  响应 体 时 ，requests  库 首先 会 使用  respone  的  encoding  属性 对 其 进行 编码 ， 最终 将 编码 后 的 结果 返回 回来 。 如果 在 调用  text  方法 前 ， 没有 明确 指定  response  的  encoding  属性 ，respone  将 尝试 按照 下列 顺序 获取 默认 的 编码 规则 ： 如果 响应 头  Content-Type  中 指定 了 编码 规则 ， 则 将  encoding  设置 为 该 指定 的 编码 规则 并 对 消息 体 进行 编码 。  >  例如 ， 如果 响应 头 中 包含 ：Content-Type: application/json; charset=utf-8  头 信息 ， 则  requests  使用  utf-8  对 响应 体 进行 编码 ； 如果 响应 头  Content-Type  的 值 为  text/*， 即 包含  text  信息 ， 则 将  encoding  属性 这 是 为  ISO-8859-1  并 对 消息 体 进行 编码 。  >  例如 ， 如果 响应 头 中 包含 ：Content-Type: text/html  头 信息 ， 则  requests  使用  ISO-8859-1  对 响应 体 进行 编码 ； 尝试 使用  chardet  库 对 内容 进行 分析 后 获取 一个 最合适 的 编码 规则 对 消息 体 进行 编码 。  >  注意 ， 这种 方式 获取 到 的 编码 规则 并 不会 赋值 给  encoding  属性 ， 因此 无法 通过  r.encoding  方式 来 获取 当前 的 编码 规则 。{{}}r = requests.get('http://httpbin.org/get')r.encoding>>>r.text>>> '{\\n  \"args\": {}, ... }{{}} 我们 也 可以 在 调用  text  方法 前 ， 明确 指定 一个 编码 规则 对 返回 的 内容 进行 编码 ， 如 ：{{}}r = requests.get('http://httpbin.org/get')r.encoding = 'ISO-8859-1'r.encoding>>> ISO-8859-1r.text>>> '{\\n  \"args\": {}, ... }'{{}}content 方法 content  是 一个 属性 函数 ， 通过 该 方法 获取 到 的 消息 体 为  bytes  类型 。 当 我们 尝试 获取 二进制 文件 时 通常 使用 这种 方式 ， 比如 下面 的 例子 展示 了   如何 下载 一个 图片 ：{{}}r = requests.get('https://httpbin.org/image/png')with open('/tmp/httpbin-image.png', 'bw+') as f:    f.write(r.content){{}}json 方法 如果  HTTP  请求 返回 的 消息 体 是  JSON  格式 的 字符串 ， 则 我们 可以 使用  json  方法 ， 将 返回 的 字符串 转换成  Python  对象 ， 如果 返回 的 对象 无法 被 正确 转换 ， 则 抛出  ValueError: No JSON object could be decoded.  异常 。{{}}r = requests.get('https://api.github.com/users/gbyukg')r.json()>>>{  'avatar_url': 'https://avatars3.githubusercontent.com/u/36716?v=4',  'bio': None,  'blog': 'http://www.cnblogs.com/gbyukg/',  'company': 'soft',  ...} 获取 某个 属性 r.json()['avatar_url']>>> 'https://avatars3.githubusercontent.com/u/36716?v=4'{{}}>  注意 ，json  方法 并 没有 被 设计 成 属性 函数 ， 因此 在 调用 该 方法 时 需要 加上 括号 ()。raw 属性 raw  是  response  对象 中 的 一个 属性 ， 而 不是 方法 ， 它 指向 了 原始  socket  响应 对象 ， 该 响应 对象 包含 了 一系列 方法 ， 我们 可以 向 访问 文件 流 那样 访问 它 里面 的 内容 。 当 我们 尝试 使用  raw  属性 获取 响应 体 内容 时 ， 在 请求 方法 中 ， 必须 同时 指定  stream=Tre  参数 ， 来 防止  requests  库 自动 读取 获取 响应 体 中 的 内容 到 内存 中 ， 当 读取 响应 体 内容 比较 多 的 请求 时会 节省 很多 内存 和 时间 ， 如 ：{{}}r = requests.get('https://www.python.org//static/img/python-logo.png', stream=True)r.raw>>> 获取 当前 流 中 的 剩余 未 读 字节数 r.raw.length_remaining>>> 10102 获取 当前 流 指针 索引 r.raw.tell()>>> 0 读取  10  个 字节 r.raw.read(10)>>> b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00' 再次 去 读 剩余 字节数 r.raw.length_remaining>>> 10092 当前 流 指针 向前 移动 10 个 字节 ， 因为 我们 已经 读取 了  10  个 字节 r.raw.tell()>>> 10{{}} 更 多 关于  raw  对象 的 使用 方法 ， 请 参考  urllib3.response moduleiter_content 方法 虽然 使用  response  的  raw  属性 读取 响应 体 内容 时 可以 让 我们 在 真正 需要 的 时候 手动 获取 这些 内容 ，response  对象 提供 了 更加 方便 的 方法  iter_content， 该 方法 实际上 就是 通过 读取  raw.stream  文件 流 来 获取 内容 ， 它 可以 接收 两个 参数 ：chunk_size： 整数型 参数 ， 表示 每次 读取 多少 个 字节数 ， 默认 为  1decode_unicode： 布尔 型 参数 ， 如果 指定 为  True，  则 对 读取 的 内容 使用  r.encoding  进行 编码 ， 默认 为  False。{{}}with open(filename, 'wb') as fd:    for chunk in r.itercontent(chunksize=128):        fd.write(chunk){{}}iter_lines 方法 {{}}r.request{{}}request  对象 方法 ok 属性 status_code, headers, 自定义 请求 头 上传下载 文件 cookiessession 重定向 历史记录 certificat 错误 和 异常 DEFAULTCABUNDLE_PATH：/usr/local/lib/python2.7/site-packages/certifi/cacert.pem","title":"Python Requests  库 ","oriTitle":"Python Requests 库"}]