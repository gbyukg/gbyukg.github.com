<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><title>Python 中的 Metaclass | World of Forks</title><meta name="viewport" content="width=device-width,user-scalable=no,maximum-scale=1,initial-scale=1"><link rel="canonical" href="https://gbyukg.github.io/posts/python-metaclass/"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><link rel="stylesheet" href="https://gbyukg.github.io/css/index-37cec208b5.css"><link href="https://gbyukg.github.io/index.xml" rel="alternate" type="application/rss+xml" title="World of Forks"><link href="https://gbyukg.github.io/index.xml" rel="feed" type="application/rss+xml" title="World of Forks"><link href="https://gbyukg.github.io/favicon.ico" rel="shortcut icon"><script>window.baseURL = 'https:\/\/gbyukg.github.io';</script></head><body><div class="navbar-fixed"><nav class="navbar"><div class="nav-container container"><div class="nav-wrapper inner"><a href="javascript:void(0)" data-activates="sidebar" class="button-collapse hide-on-large-only"><i class="material-icons">menu</i> </a><a href="https://gbyukg.github.io" class="brand-logo"><i class="material-icons hide-on-med-and-down">restaurant_menu</i> World of Forks</a><ul class="nav-menu tabs tabs-transparent hide-on-med-and-down"><li class="tab"><a href="https://gbyukg.github.io/" class="">Home</a></li><li class="tab"><a href="https://gbyukg.github.io/archive/" class="">Archive</a></li><li class="tab"><a href="https://gbyukg.github.io/about/" class="">About</a></li></ul><form class="nav-form hide-on-small-and-down"><div class="form-group"><i class="material-icons">search</i> <input type="text" placeholder="输入搜索关键字"></div><div class="form-popout"><div class="search-result"><label>暂无搜索结果</label><ul></ul></div></div></form><ul class="nav-menu apps"><li><a class="search-btn hide-on-med-and-up" href="#search-panel"><i class="material-icons">search</i></a></li><li><a class="term-btn hide-on-small-and-down" href="#term-panel"><i class="material-icons">apps</i></a></li><li><a class="rss-btn hide-on-small-and-down" href="https://gbyukg.github.io/index.xml" target="_blank"><i class="material-icons">rss_feed</i></a></li></ul></div></div></nav></div><div class="mobile-search hide-on-med-and-up"><div class="header"><i class="material-icons">search</i> <input type="text" placeholder="输入搜索关键字"> <i class="material-icons mobile-search-close">cancel</i></div><div class="content"><label>暂无搜索结果</label><ul></ul></div></div><div class="taxonomy"><div class="container"><div class="inner"><div class="taxonomy-panel"><div class="group"><label>Category</label><ul><li><a class="btn btn-secondary" href="https://gbyukg.github.io/categories/devops">devops <span class="badge">3</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/categories/programming">programming <span class="badge">3</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/categories/system">system <span class="badge">3</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/categories/database">database <span class="badge">1</span></a></li></ul></div><div class="group"><label>Tag</label><ul><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/centos">centos <span class="badge">3</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/python">python <span class="badge">3</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/aix">aix <span class="badge">2</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/apache">apache <span class="badge">1</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/db2">db2 <span class="badge">1</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/design-patterns">design-patterns <span class="badge">1</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/devops">devops <span class="badge">1</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/jenkins">jenkins <span class="badge">1</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/linux">linux <span class="badge">1</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/php">php <span class="badge">1</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/ubuntu">ubuntu <span class="badge">1</span></a></li><li><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库 <span class="badge">1</span></a></li></ul></div></div></div></div></div><ul class="side-nav" id="sidebar"><li><a href="https://gbyukg.github.io/" class="">Home</a></li><li><a href="https://gbyukg.github.io/archive/" class="">Archive</a></li><li><a href="https://gbyukg.github.io/about/" class="">About</a></li><li><a class="term-btn-mobile hide-on-med-only" href="https://gbyukg.github.io/categories/">Categories</a></li><li><a class="term-btn-mobile hide-on-med-only" href="https://gbyukg.github.io/tags/">Tags</a></li><li><a class="rss-btn-mobile hide-on-med-only" href="https://gbyukg.github.io/index.xml" target="_blank">Rss</a></li></ul><main id="single" role="main" class="main-panel"><div class="page-content"><div class="container container-ex"><div class="inner"><section class="post-wrapper"><div class="toc-panel"><nav id="TableOfContents"><ul><li><ul><li><a href="#python-中的类">Python 中的类</a><ul><li><a href="#类也是对象">类也是对象</a></li></ul></li><li><a href="#type-关键字">type 关键字</a><ul><li><a href="#使用-type-动态创建类">使用 type 动态创建类</a></li></ul></li><li><a href="#元类-metaclass">元类（Metaclass）</a><ul><li><a href="#自定义元类">自定义元类</a><ul><li><a href="#1-函数作为元类">1.函数作为元类</a></li><li><a href="#2-类作为元类">2.类作为元类</a><ul><li><a href="#元类中的-init-和-call">元类中的 <strong><code>__init__</code></strong> 和 <strong><code>__call__</code></strong></a></li></ul></li></ul></li><li><a href="#正确使用元类的姿势">正确使用元类的姿势</a><ul><li><a href="#python2">Python2</a></li><li><a href="#python3">Python3</a></li></ul></li><li><a href="#元类的继承性">元类的继承性</a></li><li><a href="#metaclass-是如何工作的">Metaclass 是如何工作的？</a></li></ul></li><li><a href="#结束语">结束语</a></li></ul></li></ul></nav></div><div class="post reveal"><div class="card"><section class="breadcrumb-root"><div class="breadcrumbs" role="navigation" aria-label="breadcrumbs navigation"><a class="breadcrumb" href="https://gbyukg.github.io"><i class="material-icons">location_on</i>Home</a> <span class="breadcrumb">Python 中的 Metaclass</span></div></section><div class="card-header postinfo"><span class="card-title">Python 中的 Metaclass</span></div><div class="card-header date"><div class="group"><i class="material-icons">book</i><address>归档： <a href="https://gbyukg.github.io/categories/programming">Programming</a>&nbsp;</address></div><div class="group"><i class="material-icons">flag</i> <time>创建：2018年01月29日</time></div><div class="group"><i class="material-icons">mode_edit</i> <time>修改：2018年02月28日</time></div></div><div class="card-content"><article class="article"><p>Metaclass 作为 Python 中的一种高级用法，开发人员平时很少会直接使用到它。然而一旦我们真正掌握了 metaclass，不仅会让我们编写出更高效的代码，而且会对 Python 中的类会有更加深刻的理解。<br><br></p><p>在介绍 Metaclass 之前，先让我们看一下 Python 中的类。</p><h2 id="python-中的类">Python 中的类</h2><p>相信大家对类的概念并不陌生，我们通常将类比作为蓝图，实例化类就指是根据这个蓝图，创建出一个个具体的实例来。也可以理解为，类就是用来创建类实例对象的：</p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">6
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>():
    <span style="color:#66d9ef">pass</span>

my_obj <span style="color:#f92672">=</span> MyClass()
<span style="color:#66d9ef">print</span>(my_obj)
<span style="color:#75715e"># &gt;&gt;&gt; &lt;__main__.MyClass object at 0x101baebe0&gt;</span></code></pre></td></tr></table></div></div><p>在这段代码中，我们创建了一个类的实例对象，并让变量 <code>my_obj</code> 指向这个新创建的实例对象，最终成功打印出了这个对象。类 <code>MyClass</code> 可以看做是创建实例对象 <code>my_obj</code> 的 <strong>材料</strong>。<br><br></p><h3 id="类也是对象">类也是对象</h3><p><strong>在 Python 中，类不仅仅可以用来创建对象的，同时，类本身也是一个对象</strong>（这也符合 Python 中一切皆对象的说法）。<br><br></p><p>这意味着我们可以：</p><ul><li>将类赋值给一个变量<br></li><li>拷贝类<br></li><li>将类作为参数传递给其他类或方法<br></li><li>为类添加属性<br><br></li></ul><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 1
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 7
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 8
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">13
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">14
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">16
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38">my_class <span style="color:#f92672">=</span> MyClass
</span><span style="color:#66d9ef">print</span>(my_class)
<span style="color:#75715e"># &gt;&gt;&gt; &lt;class &#39;__main__.MyClass&#39;&gt;</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print_obj</span>(obj):
    <span style="color:#66d9ef">print</span>(obj)

<span style="display:block;width:100%;background-color:#3c3d38">print_obj(MyClass)
</span><span style="color:#75715e"># &gt;&gt;&gt; &lt;class &#39;__main__.MyClass&#39;&gt;</span>

<span style="color:#66d9ef">print</span>(hasattr(MyClass, <span style="color:#e6db74">&#39;new_attribute&#39;</span>))
<span style="color:#75715e"># &gt;&gt;&gt; False</span>

<span style="display:block;width:100%;background-color:#3c3d38">MyClass<span style="color:#f92672">.</span>new_attribute <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;foo&#39;</span>
</span><span style="color:#66d9ef">print</span>(hasattr(MyClass, <span style="color:#e6db74">&#39;new_attribute&#39;</span>))
<span style="color:#75715e"># &gt;&gt;&gt; True</span></code></pre></td></tr></table></div></div><p>代码解析：</p><ul><li>第 1 行中我们将类赋值给变量 <code>my_class</code>, 并成功地打印出了这个类。<br></li><li>第 8 行中将类作为参数，传递给 <code>print_obj</code> 函数。<br></li><li>第 14 行中，动态为类添加新属性。<br><br></li></ul><p>既然类本身也是作为一个对象存在的，那么它也一定是通过某些 <strong>材料</strong> 被创建出来的，那么创建类的材料又是什么呢？答案是 <code>type</code>。</p><hr><h2 id="type-关键字">type 关键字</h2><p>你一定不会对 Python 中的 <code>type</code> 关键字感到陌生，我们通常向它传递一个对象作为唯一的参数，来返回这个对象的类型，例如：</p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">6
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> type(<span style="color:#ae81ff">1</span>)
<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">int</span><span style="color:#e6db74">&#39;&gt;</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#e6db74">&gt;&gt;&gt; type(&#39;</span>string<span style="color:#e6db74">&#39;)</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#e6db74">&lt;class &#39;</span>str<span style="color:#e6db74">&#39;&gt;</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#e6db74">&gt;&gt;&gt; type(())</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#e6db74">&lt;class &#39;</span>tuple<span style="color:#e6db74">&#39;&gt;</span></code></pre></td></tr></table></div></div><p>如果我们继续对 Python 内置的类型进行 <code>type</code> 操作，会发生什么呢？</p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">6
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> type(int)
<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">type</span><span style="color:#e6db74">&#39;&gt;</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#e6db74">&gt;&gt;&gt; type(str)</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#e6db74">&lt;class &#39;</span>type<span style="color:#e6db74">&#39;&gt;</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#e6db74">&gt;&gt;&gt; type(tuple)</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#e6db74">&lt;class &#39;</span>type<span style="color:#e6db74">&#39;&gt;</span></code></pre></td></tr></table></div></div><p>会发现他们的类型全部是 <code>type</code>。</p><p>对我们刚刚定义的类 <code>MyClass</code> 进行同样的 type 测试：<br></p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">2
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> type(MyClass)
<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">type</span><span style="color:#e6db74">&#39;&gt;</span></code></pre></td></tr></table></div></div><p></p><p>其结果也是 <code>type</code>， 这说明这些内置类型，包括我们自定义的 <code>MyClass</code> 类，全部都是通过 <code>type</code> 创建出来的，这又是为什么呢？</p><h3 id="使用-type-动态创建类">使用 type 动态创建类</h3><p><code>type</code> 不仅仅可以用来判断某个对象的类型，它还有另一个鲜为人知的强大功能，就是用来创建类，其格式为：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">type(name, bases, dict)</code></pre></div><blockquote><p>这是典型的多态性，根据不同的参数，其行为也随之不同。</p></blockquote><p>它一共接受三个参数：</p><ul><li><code>name</code>: 字符串类型，指定了我们要创建的类的名称。<br></li><li><code>base</code> 元组类型，指定了新创建类的所有父类，如果无需继承任何父类，则传递一个空元组。<br></li><li><code>attrs</code> 字典类型，指定了新创建类中的所有属性，如果不包含任何属性，则传递一个空字典。<br><br></li></ul><p>下面，我们通过一个简单的例子，创建一个不包含任何属性的空类：</p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">1
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">MyClass <span style="color:#f92672">=</span> type(<span style="color:#e6db74">&#39;MyClass&#39;</span>, (), {})</code></pre></td></tr></table></div></div><p>我们使用 <code>type</code> 关键字创建了一个名为 <code>MyClass</code> 的类，这个类没有继承任何父类，也不包含任何属性和方法，并将这个类赋给变量 <code>MyClass</code>，使其这个变量指向我们刚刚创建的类。</p><blockquote><p>注意：这里我们使用了相同的名字 <code>MyClass</code> 同时作为类名和变量名，这并不是必须的，但为了减少疑惑，提升代码可读性，尽量采用统一的名字。</p></blockquote><p>上面的代码完全等价于我们使用 <code>class</code> 关键字创建的类：</p><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>():
    <span style="color:#66d9ef">pass</span></code></pre></div><p>这就是为什么当我们使用 <code>type(MyClass)</code> 时，返回的结果为 <code>type</code> 类型，这也是 Python 创建类的默认方式。<br><br></p><p>现在，让我们看一个更复杂一点的例子:<br></p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 1
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 3
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 4
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 6
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 7
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">10
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_name</span>(self):
</span>    <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>name

<span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">init</span>(self, name):
</span>    self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name

<span style="display:block;width:100%;background-color:#3c3d38">MyClass <span style="color:#f92672">=</span> type(<span style="color:#e6db74">&#39;MyClass&#39;</span>, (object,), {<span style="color:#e6db74">&#39;get_name&#39;</span>:get_name, <span style="color:#e6db74">&#39;__init__&#39;</span>:init})
</span>my_obj <span style="color:#f92672">=</span> MyClass(<span style="color:#e6db74">&#39;zzl&#39;</span>)
<span style="color:#66d9ef">print</span>(my_obj<span style="color:#f92672">.</span>get_name())
<span style="color:#75715e"># &gt;&gt;&gt; zzl</span></code></pre></td></tr></table></div></div><p></p><p>在这个例子中，我们使用 <code>type</code> 关键字创建了一个包含有两个方法的类 <code>MyClass</code>：<br><br></p><ul><li>第 1 行和第 4 行分别定义了两个函数 <code>get_name</code> 和 <code>init</code>， 这里需要注意的是，每个函数都至少需要接收一个名为 <code>self</code> 的参数作为第一个参数，因为这两个函数都将要作为类中的方法来被调用。<br></li><li>第 7 行中，指定它继承的父类为 <code>object</code> 对象，并将类中的属性名和对应的值， 通过字典的方式作为第三个参数传递给 <code>type</code>。<br><br></li></ul><p>通过这段代码，我们创建了一个名为 <code>MyClass</code> 的类，类中含有两个方法，一个是构造方法 <code>__init__</code>，和一个普通方法 <code>get_name</code>。</p><blockquote><p><em>细心的你可能已经发现了，我们为 <code>__init__</code> 变量赋予了一个不同的名的函数 <code>init</code>，这是完全可以的。</em></p></blockquote><p>Python 中的类正是通过这种方式被创建出来的。</p><hr><h2 id="元类-metaclass">元类（Metaclass）</h2><p>前文中，我们提及过 <code>type</code> 是创建类的默认材料，更准确的来说，元类（Metaclass）才是创建类的材料，即类都是通过元类被创建出来的，而 Python 中默认的元类就是 <code>type</code>。</p><h3 id="自定义元类">自定义元类</h3><p>除了使用 Python 中默认的元类 <code>type</code> 外，我们还可以自己实现自定义的元类。事实上，任何可调用对象都可作为元类，它可以是一个函数，也可以是一个类，我们只需确保该可调用对象接收与 <code>type</code> 创建类时所使用的相同的三个参数，并最终返回一个类即可。<br><br></p><p>让我们分别看一下当函数和类作为元类时的情况。</p><h4 id="1-函数作为元类">1.函数作为元类</h4><p>考虑这样一种情况，当我们创建一个类时，无论是类中的属性名还是方法名，最终我们都想将它们转化为大写形式，这时，我们就可以使用 Metaclass 来创建我们的类，在 Metaclass 中获取到类中所有用户自定义的属性，并将它们的名字转换成大写即可。</p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 1
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 4
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 5
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 9
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">10
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">13
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">14
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">15
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">16
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">17
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">18
</span></span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">upper_attr</span>(future_class_name, future_class_parents, future_class_attr):
</span>    uppercase_attr <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">for</span> name, val <span style="color:#f92672">in</span> future_class_attr<span style="color:#f92672">.</span>items():
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> name<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;__&#39;</span>):
<span style="display:block;width:100%;background-color:#3c3d38">            uppercase_attr[name<span style="color:#f92672">.</span>upper()] <span style="color:#f92672">=</span> val
</span>        <span style="color:#66d9ef">else</span>:
            uppercase_attr[name] <span style="color:#f92672">=</span> val

    <span style="color:#75715e"># 调用 type 来创建我们需要的类</span>
<span style="display:block;width:100%;background-color:#3c3d38">    <span style="color:#66d9ef">return</span> type(future_class_name, future_class_parents, uppercase_attr)
</span>
<span style="color:#75715e">#  通过 upper_attr 创建 MyClass 类</span>
<span style="color:#75715e">#  类中包含一个名为 foo 的属性</span>
<span style="display:block;width:100%;background-color:#3c3d38">MyClass <span style="color:#f92672">=</span> upper_attr(<span style="color:#e6db74">&#39;MyClass&#39;</span>, (), {<span style="color:#e6db74">&#39;foo&#39;</span>:<span style="color:#e6db74">&#39;bar&#39;</span>})
</span>
<span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#66d9ef">print</span>(hasattr(MyClass, <span style="color:#e6db74">&#39;foo&#39;</span>))  <span style="color:#75715e">#  False</span>
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#66d9ef">print</span>(hasattr(MyClass, <span style="color:#e6db74">&#39;FOO&#39;</span>))  <span style="color:#75715e">#  True</span>
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#66d9ef">print</span>(MyClass<span style="color:#f92672">.</span>FOO) <span style="color:#75715e">#  bar</span></span></code></pre></td></tr></table></div></div><p><br><br>代码解释：<br><br></p><ul><li>第 1 行，我们首先定义了一个函数，该函数接收三个参数，分别作为要创建类的类名，父类及类中的属性传递给该函数。<br></li><li>第 2 行，定义一个全局字典，用于保存将属性名转换成大写后的所有类中的属性。<br></li><li>第 5 行，将用户自定义的属性名转换成大写，并保存到全局变量 <code>uppercase_attr</code> 中。<br></li><li>第 10 行，最终还是通过调用 <code>type</code> 来创建出我们的新类并返回给调用者。后面我们会看到其他不用 <code>type</code> 方式来返回类对象的方法。<br></li><li>第 14 行，与 <code>type</code> 用法一样，这里我们通过自定义的 Metaclass 来创建类，并为该类设定了 <code>foo</code> 属性。<br></li><li>第 18 行，能够正确访问类中的 <code>FOO</code> 属性，说明属性名已经被转换成大写形式了。<br><br></li></ul><p>这是一个没有什么意义的例子，但是通过这个例子，可让让我们对元类有一个基本的理解。</p><h4 id="2-类作为元类">2.类作为元类</h4><p>虽然可以将函数作为元类来创建类，但创建一个类作为元类来使用，这将更符合 OOP 思想，并且有更多的灵活性。需要注意的是，当使用类作为元类时，必须注意以下两点：<br><br></p><ol><li>类的最顶层必须继承自 type：虽然是元类，但它同时还是一个类，这就说明作为元类的类也可以继承，但就像是 <code>object</code> 类是所有类的最顶级父类一样，<code>type</code> 必须是元类的最顶级元类。<br></li><li>按要求实现 <code>__new__</code> 方法：<code>__new__</code> 方法体内是用来实现真正创建类的代码块的，该方法除了第一个参数是类本身之外，同样还需额外的其他三个参数：<code>name</code>, <code>bases</code> 以及 <code>attrs</code> 来创建类。<br><br></li></ol><p>现在让我们通过类作为元类来实现上面的例子，将类中所有的用户自定义属性的名字转换成大写：</p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 1
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 3
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 4
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">10
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">11
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">12
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">13
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">14
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">15
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">16
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">17
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">18
</span></span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UpperAttr</span>(type):
</span>    __uppercase_attr <span style="color:#f92672">=</span> {}

<span style="display:block;width:100%;background-color:#3c3d38">    <span style="color:#66d9ef">def</span> __new__(cls, future_class_name, future_class_parents, future_class_attr):
</span>        <span style="color:#66d9ef">for</span> name, val <span style="color:#f92672">in</span> future_class_attr<span style="color:#f92672">.</span>items():
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> name<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#39;__&#39;</span>):
                cls<span style="color:#f92672">.</span>__uppercase_attr[name<span style="color:#f92672">.</span>upper()] <span style="color:#f92672">=</span> val
            <span style="color:#66d9ef">else</span>:
                cls<span style="color:#f92672">.</span>__uppercase_attr[name] <span style="color:#f92672">=</span> val
        <span style="color:#75715e"># 通过调用 super 返回类</span>
<span style="display:block;width:100%;background-color:#3c3d38">        <span style="color:#66d9ef">return</span> super(UpperAttr, cls)<span style="color:#f92672">.</span>__new__(
</span><span style="display:block;width:100%;background-color:#3c3d38">            cls,
</span><span style="display:block;width:100%;background-color:#3c3d38">            future_class_name,
</span><span style="display:block;width:100%;background-color:#3c3d38">            future_class_parents,cls<span style="color:#f92672">.</span>__uppercase_attr
</span><span style="display:block;width:100%;background-color:#3c3d38">        )
</span>
<span style="display:block;width:100%;background-color:#3c3d38">MyClass <span style="color:#f92672">=</span> UpperAttr(<span style="color:#e6db74">&#39;MyClass&#39;</span>, (), {<span style="color:#e6db74">&#39;foo&#39;</span>:<span style="color:#e6db74">&#39;bar&#39;</span>})
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#66d9ef">print</span>(MyClass<span style="color:#f92672">.</span>FOO) <span style="color:#75715e">#  bar</span></span></code></pre></td></tr></table></div></div><p><br><br>代码解释：<br><br></p><ul><li>第 1 行，创建一个继承自 <code>type</code> 的类，元类的最终父类必须要继承自 <code>type</code>。<br></li><li>第 2 行，定义私有类变量，用于保存属性名转换为大写之后的所有属性<br></li><li>第 4 行，实现了 <code>__new__</code> 方法，它一共接收 4 个参数：由 Python 自动传递类自身参数 <code>cls</code>，以及其他三个用来创建类的参数，该方法最终必须返回一个类对象。<br></li><li>第 10-15 行，这里使用 <code>super</code> 方法，而不是直接调用 <code>type</code>，虽然 Python 最终还是通过调用 <code>type</code> 来生成类的，但这种写法更加符合 OOP 编程思想，也更加灵活，比如下面将会看到的，自动调用 <code>__init__</code> 方法等。<br></li><li>第 17 行，使用元类 <code>UpperAttr</code> 来创建类我们的类，其调用方法与调用函数元类和 <code>type</code> 类似。<br></li><li>第 18 行，访问 <code>MyClass</code> 类中的 <code>FOO</code> 属性。<br><br></li></ul><h5 id="元类中的-init-和-call">元类中的 <strong><code>__init__</code></strong> 和 <strong><code>__call__</code></strong></h5><p>通过类实现的元类，本身又是一个类，因此类中的其他魔术方法，同样可以应用在我们的这个元类中，下面让我们看一下两个常用的魔术方法在元类中的应用：<br><br></p><p><strong><code>__init</code>__</strong>：与正常类中的使用方式一样，如果在元类中定义了该方法，当 <code>__new__</code> 返回后，会自动调用该方法。<br><br></p><p><strong><code>__call__</code></strong>：若在元类中定义了 <code>__call__</code> 方法，那么该方法会在被创建的类 <strong>被实例化</strong> 时自动调用，我们通常将它应用到单例模式的创建中去，考虑如下实例：</p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 1
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 5
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 6
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79"> 9
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">10
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">15
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">16
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">18
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">19
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">20
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">24
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MetaSingleton</span>(type):
</span>    <span style="color:#75715e"># 类属性，用来保存实例对象</span>
    <span style="color:#75715e"># 设置为类私有属性，防止被意外修改</span>
    __instance <span style="color:#f92672">=</span> None

<span style="display:block;width:100%;background-color:#3c3d38">    <span style="color:#66d9ef">def</span> __call__(cls, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kvargs):
</span>        <span style="color:#75715e"># 如果类属性 __instance 不为空，说明已经实例化过某个类，直接返回那个类实例即可</span>
        <span style="color:#75715e"># 如果为 None，则创建一个新的实例对象，并保存到 __instance 变量中</span>
        <span style="color:#66d9ef">if</span> cls<span style="color:#f92672">.</span>__instance <span style="color:#f92672">is</span> None:
<span style="display:block;width:100%;background-color:#3c3d38">            cls<span style="color:#f92672">.</span>__instance <span style="color:#f92672">=</span> super(MetaSingleton, cls)<span style="color:#f92672">.</span>__call__(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kvargs)
</span>
        <span style="color:#75715e"># 总是返回类属性 __instance</span>
        <span style="color:#66d9ef">return</span> cls<span style="color:#f92672">.</span>__instance

<span style="color:#75715e">#  通过 MetaSingleton 元类创建类</span>
<span style="display:block;width:100%;background-color:#3c3d38">SingletonKls <span style="color:#f92672">=</span> MetaSingleton(<span style="color:#e6db74">&#39;SingletonKls&#39;</span>, (), {})
</span>
<span style="color:#75715e">#  创建类实例</span>
<span style="display:block;width:100%;background-color:#3c3d38">my_obj1 <span style="color:#f92672">=</span> SingletonKls()
</span><span style="display:block;width:100%;background-color:#3c3d38">my_obj2 <span style="color:#f92672">=</span> SingletonKls()
</span>
<span style="color:#75715e">#  打印出实例 ID， 两次返回值一样</span>
<span style="color:#66d9ef">print</span>(id(my_obj1))
<span style="color:#66d9ef">print</span>(id(my_obj2))</code></pre></td></tr></table></div></div><p><br><br>代码解释：<br><br></p><ul><li>第 1 行：定义元类 <code>MetaSingleton</code>，并继承自 <code>type</code>。<br></li><li>第 6 行：定义 <code>__call__</code> 方法，该方法会在实例化类时被调用。<br></li><li>第 10 行：如果类属性 <code>__instance</code> 为 None，才创建新的类实例，否则返回之前已经创建过的类实例。<br></li><li>第 16 行：通过元类 <code>MetaSingleton</code> 创建我们的类。<br></li><li>第 19 行：由于实例是第一次被实例化，调用第 10 行创建新的实例，并将实例保存在了元类中的 <code>__instance</code> 属性中。<br></li><li>第 20 行：由于此时元类的类属性 <code>__instance</code> 已经保存了刚刚生成的实例对象，所以直接将上次创建的实例返回回来。<br><br></li></ul><hr><h3 id="正确使用元类的姿势">正确使用元类的姿势</h3><p>虽然我们可以使用 <code>kls = Metaclass(name, bases, attrs)</code> 的方式使用元类来生成我们的类，但这种方式不仅丑陋难用，而且非常不符合 OOP 标准，正确的使用方式是：在我们使用 <code>class</code> 关键字定义类时，明确指定我们要使用的 Metaclass。<br><br></p><p>在 Python2 和 Python3 中，指定 Metaclass 的方式是不同的，让我们分别看一下如何在两个版本中分别使用 Metaclass。</p><h4 id="python2">Python2</h4><p>在 Python2 中，通过在类中设定 <code>__metaclass__</code> 属性来指定我们要使用的元类，如：</p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">2
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>(object):
    __metaclass__ <span style="color:#f92672">=</span> MetaSingleton</code></pre></td></tr></table></div></div><h4 id="python3">Python3</h4><p>在 Python3 中，声明 Metaclass 是在类名后面的括号中，通过关键字 <code>metaclass</code> 来指定的：<br></p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">1
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>(metaclass<span style="color:#f92672">=</span>MetaSingleton): <span style="color:#66d9ef">pass</span></code></pre></td></tr></table></div></div><p></p><p>如果类同时还继承自其他类，则 <code>metaclass</code> 放在继承类的后面，并用逗号 <code>,</code> 分隔，如：<br></p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">2
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>(ParentClass, metaclass<span style="color:#f92672">=</span>MetaSingleton):
    <span style="color:#66d9ef">pass</span></code></pre></td></tr></table></div></div><p></p><div class="admonition tip"><p class="admonition-title"><i class="material-icons">assistant_photo </i>tip</p><p>Python2 与 Python3 中的声明语法是不同的，并且互不兼容，如果想编写跨平台的代码，可以引用第三方 Pyhton 库 <a href="https://pypi.python.org/pypi/six">six</a></p></div><h3 id="元类的继承性">元类的继承性</h3><p>当我们继承一个指明了元类的类，而自身并没有指明任何元类，会发生什么呢？</p><p></p><div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">1
</span></span><span style="display:block;width:100%;background-color:#3c3d38"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">2
</span></span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7c7c79">9
</span></code></pre></td><td style="vertical-align:top;padding:0;margin:0;border:0;"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Animal</span>(metaclass<span style="color:#f92672">=</span>MetaSingleton): <span style="color:#66d9ef">pass</span>
</span><span style="display:block;width:100%;background-color:#3c3d38"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span>(Animal): <span style="color:#66d9ef">pass</span>
</span>
<span style="color:#75715e"># 实例化两个 Dog 类</span>
dog1 <span style="color:#f92672">=</span> Dog()
dog2 <span style="color:#f92672">=</span> Dog()

<span style="color:#66d9ef">print</span>(id(dog1)) <span style="color:#75715e">#  4370179968</span>
<span style="color:#66d9ef">print</span>(id(dog2)) <span style="color:#75715e">#  4370179968</span></code></pre></td></tr></table></div></div><br>这是一个不太恰当的例子，但是足以说明问题了：<br><br><p></p><ul><li>第 1 行，首先我们创建了一个 Animal 的类，并为该类指定了我们的元类 MetaSingleton。<br></li><li>第 2 行，声明一个 Dog 类，继承自 Animal 类。<br></li><li>实例化两个 Dog 类，最终打印出这两个实例的 ID<br><br></li></ul><p>从结果中可以看出，他们是同一个实例对象，虽然 Dog 并没有指明元类，但是由于它的父类 <code>Animal</code> 指明了 <code>MetaSingleton</code> 元类，对于子类 <code>Dog</code> 来说，该属性被继承了下来，也就是说，此时 <code>Dog</code> 的元类也是 <code>MetaSingleton</code>。</p><div class="admonition tip"><p class="admonition-title"><i class="material-icons">assistant_photo </i>tip</p><p>在定义类时，每个类只能声明一次 metaclass，而无论 metaclass 是在父类中声明的，还是在自身类定义时声明的，否则 Python 解释器会抛出 <code>TypeError</code> 异常，提示 metaclass 冲突错误。</p></div><h3 id="metaclass-是如何工作的">Metaclass 是如何工作的？</h3><p>当我们通过直接调用元类的方式创建类时，意图很明确，我们将所有创建类所需要的数据通过参数的方式传递给元类。而通过 <code>class</code> 方式声明的类，Python 有时如何解释的呢？<br><br></p><p>当 Python 解释器遇到 <code>class</code> 关键字时，首先扫描类的内部定义，包括类变量和内部定义的所有方法，并将扫描的信息保存到 <code>__dict__</code> 字典中，此刻，在内存中，类还没有被创建；解释器接着会查看类的定义中是否声明了 metaclass，如果存在 metaclass 的声明，则调用我们声明的 metaclass ，并将类名、父类以及 <code>__dict__</code> 传递给它来创建类，否则将这些信息传递给 <code>type</code> 来创建类，并最终保将类保存到内存中。</p><h2 id="结束语">结束语</h2><p>通过 Metaclass 能够实现的大部分功能，其实通过其他方法一般也可以实现。何时需要使用 Metaclass，需要视具体情况而定，为了代码的可读性和维护性，在非必要的情况下，能避免使用 Metaclass 则尽量避免使用。</p><p><br><br><a href="https://stackoverflow.com/a/6581949/2101728">参考: stack overflow 中的神级回答</a></p></article></div><div class="card-action card-action-links"><a class="btn btn-secondary" href="https://gbyukg.github.io/tags/python">Python</a></div><div class="card-action"><div id="comment"></div><style>.v .vwrap .vheader .vinput:focus {
    border-bottom-color: #607d8b;
  }</style><script>window.VALINECONFIG = {
    el: '#comment',
    notify: false,
    verify: false,
    appId: 'EpIUIjYDVRQ3Fw4Qu9vGWbpb-gzGzoHsz',
    appKey: 'Yq4U0b4Ob2ujjlltku64dyuj',
    placeholder: '写点什么吧...',
    path: window.location.pathname,
    avatar: 'retro'
  }</script></div><div class="pagination-single"><span class="pagination-item previous"><i class="material-icons">navigate_before</i> <a href="https://gbyukg.github.io/posts/db2-install/" rel="prev">DB2 大版本升级</a> </span><span class="pagination-item next"><a href="https://gbyukg.github.io/posts/design-patterns/" rel="next">Python设计模式之 - 单例模式</a> <i class="material-icons">navigate_next</i></span></div></div></div></section></div></div></div><footer class="page-footer"><div class="container"><div class="inner"><div class="wrapper"><div class="group group-slink"><h5>World of Forks</h5><p>Theme <a href="https://github.com/stkevintan/canoe" target="_blank">canoe</a> designed by <a href="https://github.com/stkevintan" target="_blank">Kevin Tan</a> with ❤</p><ul class="slink"><li><a href="https://www.facebook.com/gbyukg" target="_blank" title="Facebook"><svg class="svg-icons svg-icons-facebook"><use xlink:href="#svg-icons-facebook"></use></svg></a></li><li><a href="https://github.com/gbyukg" target="_blank" title="Github"><svg class="svg-icons svg-icons-github"><use xlink:href="#svg-icons-github"></use></svg></a></li><li><a href="https://twitter.com/zloggg" target="_blank" title="Twitter"><svg class="svg-icons svg-icons-twitter"><use xlink:href="#svg-icons-twitter"></use></svg></a></li></ul></div><div class="group group-flink"><h5>My Friends</h5><ul><li><a href="http://www.cnblogs.com/gbyukg" target="_blank">gbyukg</a></li></ul></div></div></div></div><div class="footer-copyright"><div class="container"><div class="inner">Copyleft@Kevin Tan</div></div></div></footer></main><script type="text/javascript" async src="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script><script src="https://cdn.bootcss.com/highlight.js/9.12.0/languages/go.min.js"></script><script src="https://cdn.bootcss.com/highlight.js/9.12.0/languages/typescript.min.js"></script><script>hljs.configure({
    tabReplace: '  '
  })
  hljs.registerLanguage("graphql", function (e) { return { aliases: ["gql"], k: { keyword: "query mutation subscription|10 type interface union scalar fragment|10 enum on ...", literal: "true false null" }, c: [e.HCM, e.QSM, e.NM, { cN: "type", b: "[^\\w][A-Z][a-z]", e: "\\W", eE: !0 }, { cN: "literal", b: "[^\\w][A-Z][A-Z]", e: "\\W", eE: !0 }, { cN: "variable", b: "\\$", e: "\\W", eE: !0 }, { cN: "keyword", b: "[.]{2}", e: "\\." }, { cN: "meta", b: "@", e: "\\W", eE: !0 }], i: /([;<']|BEGIN)/ } });
  hljs.initHighlightingOnLoad();</script><script type="text/javascript" src="https://gbyukg.github.io/js/polyfill-dae721e58b.js"></script><script type="text/javascript" src="https://gbyukg.github.io/js/index-168a331ded.js"></script></body></html>